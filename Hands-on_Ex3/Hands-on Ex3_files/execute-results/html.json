{
  "hash": "be53eb2a173d3dbc5b480acd12fdd891",
  "result": {
    "markdown": "---\ntitle: \"Hands On Exercise 2.1 - Global and Local Measures of Spatial Autocorrelation\"\nauthor: \"Allan Chong\"\neditor: visual\n---\n\n\n## Overview\n\nHands On Exercise 3 - Global and Local Measures of Spatial Autocorrelation\n\nIn this hands-on exercise, we explore how to compute Global and Local Measure of Spatial Autocorrelation (GLSA) by using **spdep** package.\n\n## Getting Started\n\nThe code chunk below install & load sf, spdep, tmap & tidyverse packages into the R env\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf,tidyverse,spdep, tmap)\n```\n:::\n\n\n### Importing Hunan Geospatial sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sf = st_read(dsn=\"data/geospatial\", layer=\"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `D:\\Allanckw\\ISSS624\\Hands-on_Ex3\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n### Loading Hunan 2012 Aspatial File in CSV\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_GDP = read_csv(\"data/aspatial/hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n## Joining attribute data to the simple feature files\n\nNext, *left_join()* of **dplyr** is used to join the geographical data and attribute table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan = left_join(hunan_sf, hunan_GDP)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"County\"\n```\n:::\n:::\n\n\n## Visualizing Regional Development Indicator\n\nWe will visualize a choropleth map that displays the distribution of GDPPC 2012 using the tmap package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal = tm_shape(hunan) + \n  tm_fill(\"GDPPC\", n = 5, style=\"equal\") +\n  tm_borders(alpha=0.5) + \n  tm_layout(main.title = \"Equal interval categorization\")\n\nquantile = tm_shape(hunan) + \n  tm_fill(\"GDPPC\", n = 5, style=\"quantile\") +\n  tm_borders(alpha=0.5) + \n  tm_layout(main.title = \"Equal quantile interval categorization\")\n\ntmap_arrange(equal, quantile)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Computing Spatial Autocorrelation\n\nWe learn how to compute ***GLOBAL*** spatial autocorrelation statistics and to perform spatial complete randomness test for global spatial correlation\n\n### Computing Spatial Weights\n\nWe need to find the spatial weights first before we can compute global spatial correlation statistics. The spatial weights is used to define the neighbourhood relationships between the geographical units\n\nWe use poly2nb() of spdep package to compute the contiguity weight matrix. The function builds a neighbour list based on regions with contiguous boundaries. Using queen's contiguity weight matrix, we have\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q = poly2nb(hunan)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nFrom the results, there are 88 regions in Hunan,\n\nUsing the Queen's method, 85 of them has 11 neighbours, while only 2 of them has 1 neighbour\n\n### Building the Row-standardised weights matrix\n\nAfter computing the spatial weights, we will need to build the row standardized weights matrix. \"W\" Style will be used such that each neighbouring polygon will be assigned equal weight. This is done by taking the 1/(no. of neighbours) to each neighbouring county and then summing up the weighted income values.\n\n*Although this is the most logical way to summarize the neighbours' values, there is a **disadvantage in that polygons at the study area's boundaries will base their lagged values on fewer polygons**, which could lead to an over- or underestimation of the true degree of spatial autocorrelation in the data.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrs_wm_q = nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrs_wm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n:::\n:::\n\n\n**The Null Hypothesis**\n\n*The null hypothesis is to assume that GDPPC is randomly distributed between the different counties.*\n\n#### Computing Spatial Autocorrelation: Moran's I\n\nWe will perform Moran's I statistical test with `moran.test()` of the **spdep** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC, listw = rs_wm_q, zero.policy = TRUE, na.action = na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rs_wm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n:::\n:::\n\n\nBased on the result, we will ***reject*** the null hypothesis as the p-value is less than 0.05. In fact as the p-value is less than 0.01, we can consider that as **highly significant.**\n\nTherefore, we can conclude that the GDPPC is not randomly distributed based on Moran's I statistics\n\n#### Computing Spatial Autocorrelation: Moran's I with Monte Carlo simulation\n\nIn order to further confirm that the null hypothesis is false, we could use Monte Carlo simulation to predict potential outcomes of the event by using `moran.mc()` function of the **spdep** package. We will use 1000 simulations for this test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(908)\n\nbperm = moran.mc(hunan$GDPPC, listw = rs_wm_q, nsim=999, zero.policy = TRUE, na.action = na.omit)\n\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rs_wm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\nBased on the result, we will ***reject*** the null hypothesis as the p-value is less than 0.05. In fact as the p-value is less than 0.01, we can consider that as **highly significant** even when the statistics is repeated 1000 times.\n\nTherefore, we can conclude that the GDPPC is not randomly distributed based on Moran's I statistics with Monte Carlo simulation\n\n#### Visualizing Monte Carlo Moran's I\n\nIt is always a good practice to examine the simulated Moran's I test statistics in detail. This can be done by plotting the statistical values as a histogram by the code below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999]) #compute mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.01381501\n```\n:::\n\n```{.r .cell-code}\nvar(bperm$res[1:999]) #compute variance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.004192274\n```\n:::\n\n```{.r .cell-code}\nsd(bperm$res[1:999]) #compute std dev.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.06474778\n```\n:::\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.16447 -0.06010 -0.01643 -0.01382  0.02926  0.23767 \n```\n:::\n:::\n\n\n**Building the histogram**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, freq=TRUE, breaks = 20, xlab=\"Simulated Moran's I\")\nabline(v=0, col=\"blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nUsing ggplot, we can reproduce the same graph, however we need to convert the result into a data frame first\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf = data.frame(bperm$res) #convert to data frame\n\nggplot(df, aes(bperm$res)) + #aes = column name\n  geom_histogram(bins=20, \n                 color=\"White\", \n                 fill=\"lightblue\") +\n  labs(x = \"Simulated Moran's I\",\n       y = \"Frequency\") +\n  geom_vline(aes(xintercept=0),   \n               color=\"red\", linetype=\"dashed\", size=1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nThe reason why abline is set to 0 is because it must fall between \\[-1, 1\\].\n\nNegative correlation is -1, No correlation is 0, Positive correlation is 1\n\nThere is a positive correlation based on the result of the histogram for Moran's I Statistics\n\n### Visualising Geary's C test\n\n#### Computing Spatial Autocorrelation: Geary's C\n\nWe will perform Geary's C statistical test with `geary.test()` of the **spdep** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, list=rs_wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rs_wm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n:::\n:::\n\n\nBased on the result, we will ***reject*** the null hypothesis as the p-value is less than 0.05. In fact as the p-value is less than 0.01, we can consider that as **highly significant.**\n\nTherefore, we can conclude that the GDPPC is not randomly distributed based on Geary's C statistics\n\n#### Computing Spatial Autocorrelation: Geary's C with Monte Carlo simulation\n\nIn order to further confirm that the null hypothesis is false, we could use Monte Carlo simulation to predict potential outcomes of the event by using geary`.mc()` function of the **spdep** package. We will use 1000 simulations for this test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(908)\n\nbpermG = geary.mc(hunan$GDPPC, listw = rs_wm_q, nsim=999)\n\nbpermG\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rs_wm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\nBased on the result, we will ***reject*** the null hypothesis as the p-value is less than 0.05. In fact as the p-value is less than 0.01, we can consider that as **highly significant** even when the statistics is repeated 1000 times.\n\nTherefore, we can conclude that the GDPPC is not randomly distributed based on Geary's C statistics with Monte Carlo simulation\n\n#### Visualising Monte Carlo Geary's C\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bpermG$res[1:999]) #compute mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.002273\n```\n:::\n\n```{.r .cell-code}\nvar(bpermG$res[1:999]) #compute variance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.007094831\n```\n:::\n\n```{.r .cell-code}\nsd(bpermG$res[1:999]) #compute std dev.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.08423082\n```\n:::\n\n```{.r .cell-code}\nsummary(bpermG$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7135  0.9477  1.0010  1.0023  1.0577  1.2441 \n```\n:::\n:::\n\n\n**Building the histogram**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bpermG$res, freq=TRUE, breaks=20, xlab = \"Simulated Geary c\")\nabline (v=1, col=\"blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nUsing ggplot, we can reproduce the same graph, however we need to convert the result into a data frame first\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_G = data.frame(bpermG$res) #convert to data frame\n\nggplot(df_G, aes(bpermG$res)) + #aes = column name\n  geom_histogram(bins=20, \n                 color=\"White\", \n                 fill=\"lightblue\") +\n  labs(x = \"Simulated Geary's C\",\n       y = \"Frequency\") +\n  geom_vline(aes(xintercept=1),   \n               color=\"red\", linetype=\"dashed\", size=1)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nThe reason why abline is set to 1 is because it must fall between \\[0, 2\\].\n\nNegative correlation is 2, No correlation is 1, Positive correlation is 0, notice that it is essentially the opposite from Moran's I\n\nIn Moran I the smaller the number, indicates negative correlation (small -\\> -ve), in contrast in Geary's C the smaller the number indicates positive correlation (small -\\> +ve)\n\nThere is a positive correlation based on the result of the histogram for Geary's C statistics\n\n## Spatial Correlogram\n\nExamining spatial autocorrelation patterns in the data or model residuals is made simple with spatial correlograms.\n\nThey are graphs of some measure of autocorrelation (Moran's I or Geary's C) against distance and they demonstrate how correlated pairs of spatial observations are as one increase the distance (lag) between them.\n\n### Computing Moran's I correlogram\n\nWe use `sp.correlogram()` of **spdep** package to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Moran's I\n\n`Plot()` is used to draw the output\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_Corr = sp.correlogram(wm_q, hunan$GDPPC, order = 6, method = \"I\", style = \"W\")\n\nplot(MI_Corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nPlotting the output might not allow us to provide complete interpretation, this is because not all autocorrelation values are statistically significant. Hence we should analyze the report by printing out the result\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_Corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\nThe p value is \\< 0.05 and hence is statically significant except for the 4th neighbour with p value at 0.226.\n\nWe can tell that GDPPC is positively correlated for counties up to a distance of 3 neighbours, and negatively correlated from the 5th neighbour onwards.\n\nAs the 4th degree neighbour is not statistically significant, we will **not reject** the null hypothesis of it being random.\n\n### Computing Geary's C correlogram\n\nWe use `sp.correlogram()` of spdep package to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Geary's C\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_Corr = sp.correlogram(wm_q, hunan$GDPPC, order = 6, method = \"C\", style = \"W\")\n\nplot(GC_Corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nPlotting the output might not allow us to provide complete interpretation, this is because not all autocorrelation values are statistically significant. Hence we should analyze the report by printing out the result\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_Corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\nIn this case, it is only statistically significant for the 1st, 2nd and 5th degree neighbour for GDPPC to be correlated by distance. The rest of the neighbours are not and appears to be random for the Geary's C method.\n\n## Cluster and Outlier Analysis\n\nStatistics called Local Indicators of Spatial Association, or LISA, assess whether clusters exist in the spatial arrangement of a given variable.\n\nLocal clusters in the rates, for example, indicate that some census tracts in a given city have greater or lower rates than would be predicted by chance alone; that is, the values observed are higher or lower than those of a random distribution in space.\n\nWe will use relevant ***Local Indicators for Spatial Association (LISA)***, particularly ***local Moran'I,*** in this section to identify clusters and/or outliers in the GDP per capita 2012 figures for Hunan Province.\n\n### Computing local Moran's I\n\nThe `localmoran()` function of **spdep** will be used to calculate local Moran's I. Given a collection of *l_i* values, *z_i* values and a *listw* object with neighbour weighting details for the polygon associated with the *z_i* values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfips = order(hunan$County)\nlocalMI = localmoran(hunan$GDPPC, rs_wm_q)\nhead(localMI)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n```\n:::\n:::\n\n\n`localmoran()` function returns a matrix of values whose columns are:\n\n-   *Ii*: the local Moran's I statistics\n\n-   *E.Ii:* the expectation (**mean**) of local Moran statistic under the randomization hypothesis\n\n-   *Var.Ii:* the **variance** of local Moran statistic under the randomization hypothesis\n\n-   *Z.Ii*: the **standard deviation** of local Moran statistic\n\n-   *Pr*: the **p-value** of local Moran statistic\n\nWe can print the local Moran matrix by `printCoefmat`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprintCoefmat(data.frame(localMI[fips,], \n                        row.names=hunan$County[fips]), \n                        check.names=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       Ii        E.Ii      Var.Ii        Z.Ii Pr.z....E.Ii..\nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -7.2467e-02         0.9422\nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791e+00         0.1391\nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -6.6269e-02         0.9472\nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185e+00         0.2230\nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  1.2932e-01         0.8971\nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -7.6828e-02         0.9388\nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590e+00         0.0008\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895e+00         0.1119\nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  6.8299e-01         0.4946\nCili           7.3176e-02 -1.6747e-03  4.7902e-02  3.4200e-01         0.7324\nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297e+00         0.3032\nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159e+00         0.1882\nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338e+00         0.1023\nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  5.1198e-01         0.6087\nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -9.5104e-01         0.3416\nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305e+00         0.3028\nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  7.7931e-01         0.4358\nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  2.6266e-01         0.7928\nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  1.2742e-01         0.8986\nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  4.6294e-01         0.6434\nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -2.5618e-01         0.7978\nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  4.3486e-01         0.6637\nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678e+00         0.2856\nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -4.7503e-02         0.9621\nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  5.4072e-01         0.5887\nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  7.9685e-01         0.4255\nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -5.3633e-01         0.5917\nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204e+00         0.3076\nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  7.1800e-01         0.4728\nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759e+00         0.2396\nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -1.9667e-02         0.9843\nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543e+00         0.1756\nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  4.4972e-01         0.6529\nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  2.3422e-01         0.8148\nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623e+00         0.2451\nLi             1.0225e-03 -2.4048e-07  5.1060e-06  4.5260e-01         0.6508\nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467e+00         0.2952\nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335e+00         0.0329\nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  3.9086e-01         0.6959\nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -1.7676e-01         0.8597\nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  1.3634e-01         0.8916\nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972e+00         0.0052\nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787e+00         0.0376\nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690e+00         0.1710\nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  9.9561e-01         0.3194\nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  7.1663e-01         0.4736\nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715e+00         0.0004\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -1.0988e-01         0.9125\nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274e+00         0.0676\nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  7.5356e-01         0.4511\nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698e+00         0.0000\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  7.6396e-01         0.4449\nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  6.7712e-01         0.4983\nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -7.1814e-01         0.4727\nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  9.7972e-01         0.3272\nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510e+00         0.1468\nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583e+00         0.0631\nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807e+00         0.0928\nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -4.7729e-01         0.6332\nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  6.5174e-02         0.9480\nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  8.5358e-01         0.3933\nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544e+00         0.0637\nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002e+00         0.0357\nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  5.0903e-01         0.6107\nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582e+00         0.2900\nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873e+00         0.0001\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935e+00         0.0283\nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213e+00         0.0000\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092e+00         0.0704\nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539e+00         0.0507\nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  4.2409e-01         0.6715\nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  2.6667e-01         0.7897\nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502e+00         0.1211\nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  1.9289e-01         0.8470\nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -6.8395e-03         0.9945\nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726e+00         0.1699\nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -6.8667e-01         0.4923\nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202e+00         0.2224\nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795e+00         0.1390\nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409e+00         0.2539\nYou            7.8750e-02 -7.2728e-03  1.2116e-01  2.4714e-01         0.8048\nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  6.9181e-03         0.9945\nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121e+00         0.0700\nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  8.6085e-01         0.3893\nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  9.2214e-01         0.3565\nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855e+00         0.2358\nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688e+00         0.0001\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -7.0144e-01         0.4830\n```\n:::\n:::\n\n\n#### Mapping the local Moran's I\n\nBefore mapping the local Moran's I map, we need to append the local Moran's I data frame (`localMI`) onto the Hunan's spatial polygon data frame by using `cbind()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan.localMI = cbind(hunan, localMI) %>% #pipe\n                rename(Pr.Ii = Pr.z....E.Ii..)\n```\n:::\n\n\nAfter creating the the new data frame `hunan.localMI`, we can use the **tmap** package to plot the local Moran's I values\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hunan.localMI) + \n  tm_fill(col=\"Ii\", #note that actual value is li\n          style=\"pretty\", palette = \"PuRd\", title = \"Local Moran's I Statistics\") + \n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n#### Mapping local Moran's I p-values\n\nThe choropleth map shows that there is evidence for both positive & negative li values. However, we need to consider the p-values for each of these values to determine if they are statistically significant\n\nBy using breaks and fixed style, we can determine which are the areas that are statistically significant\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hunan.localMI) + \n  tm_fill(col=\"Pr.Ii\", #note that p value is Pr.li\n          breaks=c(-Inf, 0.001, 0.01, 0.05, Inf),\n          style=\"fixed\",\n          palette = \"-Greens\", title = \"Local Moran's I p values\") +   tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nIt is recommended to plot the local Moran's I values map and its associated p-values map side by side for effective interpretation, we can use `tmap_arrange()` to accomplish that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocalMI.map = tm_shape(hunan.localMI) + \n  tm_fill(col=\"Ii\", #note that actual value is li\n          style=\"pretty\", palette = \"PuRd\", title = \"Local Moran's I Statistics\") + \n  tm_borders(alpha = 0.5)\n\n\npvalue.map = tm_shape(hunan.localMI) + \n  tm_fill(col=\"Pr.Ii\", #note that p value is Pr.li\n          breaks=c(-Inf, 0.001, 0.01, 0.05, Inf),\n          style=\"fixed\",\n          palette = \"-Greens\", title = \"Local Moran's I p values\") +   tm_borders(alpha = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n#### The Null Hypothesis of Local Moran's I Statistics\n\nThe null hypothesis of Local Moran's I statistics is that there is no correlation between the value at one site and the values at other locations close by. (Long, n.d.)\n\n#### Analysis of Results of Local Moran's I Statistics - Dissimilar Features (\\< 0)\n\nThe figure below shows the various clusters boxed up that are considered outliers as their I value is less than zero.\n\nAfter superimposing it with the p value map, we can infer that\n\n-   Only 2 areas are statistically significant (labelled by **sig**), which we can reject the null hypothesis to conclude that there is indeed a correlation in these 2 areas that their neighbouring features having dissimilar characteristics.\n\n-   All other regions that does not have a **sig** label, the null hypothesis is accepted and they have a negative local Moran I value purely due to chance.\n\n![](local%20moran%20outliers.png){width=\"526\"}\n\n#### Analysis of Results of Local Moran's I Statistics - Similar Features (\\>= 0)\n\nThe figure below shows the various clusters boxed up with similarly high or low attribute values as the local Moran I Statistics is more than or equal to zero.\n\nAfter superimposing it with the p value map, we can infer that\n\n-   Cluster A is the most statistically significant, the area GDPPC is highly influence by its neighbours as we reject the null hypothesis. Only 2 areas has very different features as explained in the previous section. The 2 dissimilar area however, seems to suggest that they are outskirt of cluster A.\n\n-   In Cluster B, only 4 sites are influence by one another, however the influence is weak as the I statistics is between zero and one\n\n-   In cluster C, it looks like only its first degree neighbour has some influence over the GDPPC of the area in the statistically significant lone area\n\n-   In all other regions. the null hypothesis is accepted and they have a positive local Moran I value purely due to chance.\n\n![](local%20moran%20similar.png){width=\"509\"}\n\n## Creating a LISA Cluster Map\n\nThe relevant sites are color coded on the LISA Cluster Map according to the type of spatial autocorrelation.\n\nThe Moran scatterplot **must first be drawn** before we can create the LISA cluster map.\n\n### Plotting Moran Scatterplot\n\n-   A helpful visual tool for exploratory analysis is the Moran scatter plot, which helps one to judge how similar an observed value is to its nearby observations.\n\n-   The y axis, also referred to as the response axis , is dependent on the values of the observations.\n\n-   Based on the weighted average or spatial lag of the corresponding observation on the X axis, the Y axis is constructed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnci = moran.plot(hunan$GDPPC, rs_wm_q, \n                 labels=as.character(hunan$County),\n                 xlab = \"GDPPC 2012\",\n                 ylab=\"Spatially lag GDPPC 2012\",\n                 xlim=c(0, 90000), ylim=c(0,60000), pch=5\n)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nThe plot is split into 4 quadrants, below is an **example** of what each quadrant represents.\n\n![](https://www.researchgate.net/profile/Cristina-Gomez-4/publication/229346700/figure/fig4/AS:300773247340565@1448721338553/Morans-I-scatterplot-The-slope-of-the-regression-line-is-an-estimation-of-the-global.png)\n\nThe global Moran's I is estimated from the slope of the regression line. The relative density of the dots in the correlation quadrants shows how association between high and/or low values determines the overall measure of spatial relationship. (Figure 5, Gomez, et al, 2011)\n\n#### **Analysis**\n\n-   From the resulting plot, we can see that majority of the points are positively correlated but are below the average.\n\n-   The areas that are above the average in the high-high quadrant are likely represented by purple and dark red spots on the local Moran's I map in Cluster A.\n\n-   ZiXing and LengShuiJiang are likely the 2 areas with dissimilar features in cluster A as previously explained.\n\n### Preparing LISA map classes\n\n1.  Create the quadrants\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    quadrant = vector(mode=\"numeric\",length=nrow(localMI))\n    ```\n    :::\n\n\n2.  Center the variable of interest around its mean\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    DV = hunan$GDPPC - mean(hunan$GDPPC)\n    ```\n    :::\n\n\n3.  Center the local Moran's I value around the mean\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    C_MI = (localMI[,1] - mean(localMI[,1]))\n    ```\n    :::\n\n\n4.  Setup the statistically significant levels for the local Moran\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    signif = 0.05\n    ```\n    :::\n\n\n5.  Define the quadrants levels\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    quadrant[DV > 0 & C_MI > 0] = 4\n    quadrant[DV < 0 & C_MI < 0] = 1\n    quadrant[DV < 0 & C_MI > 0] = 2\n    quadrant[DV > 0 & C_MI < 0] = 3\n    ```\n    :::\n\n\n6.  Place non significant Moran into category 0\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    quadrant[localMI[,5]>signif] = 0\n    ```\n    :::\n\n\n7.  Plotting the LISA Map\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    hunan.localMI$quadrant <- quadrant\n    colors = c(\"white\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\n    clusters = c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n    \n    tm_shape(hunan.localMI) + \n      tm_fill(col=\"quadrant\", style=\"cat\", \n              palette = colors[c(sort(unique(quadrant)))+1], \n              labels = clusters[c(sort(unique(quadrant)))+1],\n              popup.vars = c(\"\")) +\n              tm_view(set.zoom.limits = c(11,17)) +\n              tm_borders(alpha=0.5)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](Hands-on-Ex3_files/figure-html/unnamed-chunk-35-1.png){width=672}\n    :::\n    :::\n\n\nFor effective interpretation, it is better to plot both the LISA map and its corresponding p-values map next to each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\")\n\nhunan.localMI$quadrant <- quadrant\ncolors = c(\"white\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters = c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAMap = tm_shape(hunan.localMI) + \n  tm_fill(col=\"quadrant\", style=\"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n          tm_borders(alpha=0.5)\n\n#tmap_arrange(localMI.map, LISAMap, pvalue.map, asp=1, ncol=3)\ntmap_arrange(gdppc, LISAMap, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n#### **Analysis**\n\n-   Comparing the GDPPC and LISA maps, it tallies with the analysis in the Local Moran's section that the dissimilar areas have low GDPPC, while similar regions have high GDPPC in cluster A\n\n-   There are also 2 low high areas in cluster B, these are outliers that neighbours affects its GDPPC. They are likely to be ZhuZhou and XiangTan in the Moran Scatter plot\n\n-   In cluster C, the significant area is likely PingJiang as an outlier in the Moran Scatter plot, where most neighbouring counties have low GDPPC, while it has a GDPPC of between 20k to 40k. However, in the LISA plot, it is insignificant.\n\nFor reference, the figure below was previously discussed in the Local Moran's Section.\n\n![](images/paste-FBE3E7C5.png){width=\"470\"}lies,\n\n### Hot Spot and Cold Spot Area Analysis\n\nBeside detecting cluster and outliers, localised spatial statistics can be also used to detect hot spot and/or cold spot areas.\n\nThe term 'hot spot' has been used generically across disciplines to describe a region or value that is higher relative to its surroundings (Lepers et al 2005, Aben et al 2012, Isobe et al 2015).\n\nA hot spot is a location where high values cluster together\n\nA cold spot is a location place where low values cluster together\n\n• Moran's I and Geary's C cannot distinguish them\n\n• They only indicate clustering\n\n• Cannot tell if these are hot spots, cold spots, or both\n\nTo overcome the limitations, we could use LISA maps to identify hot and cold spots.\n\n### Getis and Ord's G-Statistics\n\nThe G statistic distinguishes between hot spots and cold spots. It identifies **spatial concentrations.**\n\n-   G is relatively large if high values cluster together\n\n-   G is relatively low if low values cluster together\n\nThe General G statistic is interpreted relative to its mean (or expected) value. The value for which there is no spatial association\n\n-   G \\> expected value -\\> potential \"hot spots\"\n\n-   G \\< expected value -\\> potential \"cold spots\"\n\nThe analysis consists of three steps:\n\n1.  Deriving spatial weight matrix\n\n2.  Computing Gi statistics\n\n3.  Mapping Gi statistics\n\n### Deriving distance-based weight matrix\n\nWe must first specify a new set of neighbours. While the spatial autocorrelation took into account units that shared borders, in Getis-Ord, neighbours are determined based on distance. There are 2 types of distance-based proximity matrix, they are:\n\n1.  fixed distance weight matrix; and\n\n2.  adaptive distance weight matrix.\n\nTo get our longitude values we map the *st_centroid()* function over the geometry column of us.bound and access the longitude value through double bracket notation \\[\\[\\]\\] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude = map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n```\n:::\n\n\nWe do the same for latitude with one key difference. We access the second value per each centroid with \\[\\[2\\]\\].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n\nNow that we have latitude and longitude, we use `cbind()` to put longitude and latitude into the same object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoord = cbind(longitude, latitude)\n```\n:::\n\n\n### Determine the cut-off distance\n\n#### Find the lower and upper bounds\n\n1.  Using the k nearest neighbour (knn) algorithm, we can return a matrix with indices of points that belongs to the set of k nearest neighbours of each others by using `knearneigh()` of **spdep**\n\n2.  Convert the knn objects into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using `knn2nb()`\n\n3.  Return the length of neighbour relationship edges by using `nbdists()` of spdep. The function returns in the units of coordinates if the coordinates are projected, in km otherwise.\n\n4.  Remove the list structure of the return objects by using `unlist()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    k1 = knn2nb(knearneigh(coord)) #returns a list of nb objects from the result of k nearest neighbours matrix, Step 1 & 2\n    k1dist = unlist(nbdists(k1, coord, longlat = TRUE)) #return the length of neighbour relationship edges and remove the list structures, Step 3 & 4\n    summary(k1dist)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      24.79   32.57   38.01   39.07   44.52   61.79 \n    ```\n    :::\n    :::\n\n\n    From the result, the largest first nearest neighbour is 61.79km, hence by using this as the upper bound, we can be certain that all units will have at least 1 neighbour\n\n    `dnearneigh` will be used to compute the distance weight matrix\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    wm_d62 = dnearneigh(coord, 0, 62, longlat = TRUE)\n    wm_d62\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Neighbour list object:\n    Number of regions: 88 \n    Number of nonzero links: 324 \n    Percentage nonzero weights: 4.183884 \n    Average number of links: 3.681818 \n    ```\n    :::\n    :::\n\n\n    Next `nb2listw()` is used to convert the nb object into spatial weights objects\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    wm62_lw = nb2listw(wm_d62, style=\"B\")\n    summary(wm62_lw) \n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Characteristics of weights list object:\n    Neighbour list object:\n    Number of regions: 88 \n    Number of nonzero links: 324 \n    Percentage nonzero weights: 4.183884 \n    Average number of links: 3.681818 \n    Link number distribution:\n    \n     1  2  3  4  5  6 \n     6 15 14 26 20  7 \n    6 least connected regions:\n    6 15 30 32 56 65 with 1 link\n    7 most connected regions:\n    21 28 35 45 50 52 82 with 6 links\n    \n    Weights style: B \n    Weights constants summary:\n       n   nn  S0  S1   S2\n    B 88 7744 324 648 5440\n    ```\n    :::\n    :::\n\n\n    The fixed distance weight matrix has the property that locations with higher densities of habitation (often urban areas) tend to have more neighbours, whereas areas with lower densities (typically rural areas) tend to have fewer neighbours.\n\n    By enforcing symmetry or accepting asymmetric neighbours, as shown in the code below, it is possible to control the number of neighbours of each region using the knn algorithm.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    knn8 = knn2nb(knearneigh(coord, k=8))\n    ```\n    :::\n\n\n    Next `nb2listw()` is used to convert the nb object into spatial weights objects\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    knn_lw = nb2listw(knn8, style = \"B\")\n    summary(knn_lw)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Characteristics of weights list object:\n    Neighbour list object:\n    Number of regions: 88 \n    Number of nonzero links: 704 \n    Percentage nonzero weights: 9.090909 \n    Average number of links: 8 \n    Non-symmetric neighbours list\n    Link number distribution:\n    \n     8 \n    88 \n    88 least connected regions:\n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n    88 most connected regions:\n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n    \n    Weights style: B \n    Weights constants summary:\n       n   nn  S0   S1    S2\n    B 88 7744 704 1300 23014\n    ```\n    :::\n    :::\n\n\n## Computing Gi statistics\n\n### Gi statistics using fixed distance\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfips = order(hunan$County)\ngi.fixed = localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n```\n:::\n:::\n\n\nThe output of `localG()` is a vector of G or Gstar values, with attributes \"`gstari`\" set to TRUE or FALSE, \"call\" set to the function call, and class \"localG\".\n\nThe Gi statistics is represented as a Z-score. Greater values represent a greater intensity of clustering and the direction (positive or negative) indicates high or low clusters.\n\nNext, we will join the Gi values to their corresponding hunan sf data frame by using the `cbind()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan.gi = cbind(hunan, as.matrix(gi.fixed)) %>% #pipe\n          rename(gstat_fixed = as.matrix.gi.fixed.)\n```\n:::\n\n\nThe code above performs 3tasks.\n\n1.  First, it convert the output vector (i.e. `gi.fixed`) into r matrix object by using `as.matrix()`.\n2.  `cbind()` is used to join hunan\\@data and *gi.fixed* matrix to produce a new SpatialPolygonDataFrame called *hunan.gi*.\n\nthe field name of the gi values is renamed to *gstat_fixed* by using `rename().`\n\n### Mapping Gi values with fixed distance weights\n\nWe plot the map and the gimap side by side for analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGimap = tm_shape(hunan.gi) +\n          tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n:::\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\n#### **Analysis**\n\n### Mapping Gi values with adaptive distance weights\n\nThe code below is used to compute the Gi values for GDPPC 2012 by using an adaptive distance weight matrix (i.e *`knb_lw`*).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfips = order(hunan$County)\ngi.adaptive = localG(hunan$GDPPC, knn_lw)\nhunan.gi = cbind(hunan, as.matrix(gi.adaptive)) %>% #pipe\n            rename(gstat_adaptive = as.matrix.gi.adaptive.)\n```\n:::\n\n\nWe plot the map and the gimap side by side for analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGimap = tm_shape(hunan.gi) +\n          tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n:::\n\n::: {.cell-output-display}\n![](Hands-on-Ex3_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n#### **Analysis**\n\n## Reference\n\nAnselin L. (2020) *Local Spatial Autocorrelation (1) LISA and Local Moran* https://geodacenter.github.io/workbook/6a_local_auto/lab6a.html#local-moran\n\nArcGIS Pro 3.0, *How Spatial Autocorrelation (Global Moran's I) works*\n\nhttps://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/h-how-spatial-autocorrelation-moran-s-i-spatial-st.htm\n\nGomez, Cristina & White, Joanne & Wulder, Michael. (2011). *Characterizing the state and processes of change in a dynamic forest environment using hierarchical spatio-temporal segmentation. Remote Sensing of Environment.* 115. 1665-1679. 10.1016/j.rse.2011.02.025.\n\nLong, A (n.d.), *Local Moran*\n\nhttp://ceadserv1.nku.edu/longa//geomed/stats/localmoran/localmoran.html\n",
    "supporting": [
      "Hands-on-Ex3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}