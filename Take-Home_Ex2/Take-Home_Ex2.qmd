---
title: "Take Home Exercise 2 - Regionalization of Nigeria with Water points"
author: "Allan Chong"
editor: visual
execute: 
  warning: false
  message: false
---

## Overview

Water is a crucial resource for humanity. People must have access to clean water in order to be healthy. It promotes a healthy environment, peace and security, and a sustainable economy. However, more than 40% of the world's population lacks access to enough clean water. According to UN-Water, 1.8 billion people would live in places with a complete water shortage by 2025. One of the many areas that the water problem gravely threatens is food security. Agriculture uses over 70% of the freshwater that is present on Earth.

The severe water shortages and water quality issues are seen in underdeveloped countries. Up to 80% of infections in developing nations are attributed to inadequate water and sanitation infrastructure.

Despite technological advancement, providing rural people with clean water continues to be a key development concern in many countries around the world, especially in those on the continent of Africa.

The spatial patterns of non-functional water points will be shown in this study by using the proper global and local spatial association methodologies. We look at Nigeria's in this assignment.

#### Data points of interest

In this assignment, we will attempt to regionalize Nigeria based on the following variables:

-   Total number of functional water points

-   Total number of nonfunctional water points

-   Percentage of functional water points

-   Percentage of non-functional water points

-   Percentage of main water point technology (i.e. Hand Pump)

-   Percentage of usage capacity (i.e. \< 1000, \>=1000)

-   Percentage of rural water points

-   Percentage of potable vs non potable water points

-   Percentage of water points accessible within median of primary road network

-   Percentage of water points accessible within median of secondary road network

-   Percentage of water points accessible within median of tertiary road network

-   Percentage of water points that are managed

## Getting Started

First, we load the required packages in R

-   **Spatial data handling**

    -   **sf** and **spdep**

-   **Attribute data handling**

    -   **tidyverse** especially **readr**, **ggplot2** and **dplyr** and **funModeling**

-   **Choropleth mapping**

    -   **tmap**

-   **Multivariate data visualization and analysis**

    -   **coorplot**, **ggpubr**, and **heatmaply**

-   **Cluster analysis**

    -   **cluster**

    -   **ClustGeo**

```{r}
pacman::p_load(knitr, spdep, tmap, sf, 
               ggpubr, cluster, funModeling,
               factoextra, NbClust, #factoextra factor analysis, access clustering results
               heatmaply, corrplot, tidyverse, ClustGeo)
```

## Spatial Data

The spatial dataset used in this assignment is the Nigeria Level-2 Administrative Boundary spatial dataset downloaded from [Geoboundaries](https://www.geoboundaries.org/)

We will load the spatial features by using `st_read()` from the **sf** package

As the data we want is in WSG-84 format, we set *crs* to 4326.

We won't utilize `st_transform()` at this time because it can result in outputs with missing points after transformation, which would skew our study.

```{r}
#| eval: false
nga = st_read(dsn = "data/geospatial",
               layer = "geoBoundaries-NGA-ADM2",
               crs = 4326)
```

### Updating Spatial features that have identical name but are in different states

The following code determines whether any LGA names have been repeated. If the shapeName is not distinct for rows, duplicated() returns True. Only rows that satisfy the duplicated rows = True criterion are returned by `subset()` (Ong, 2022).

```{r}
#| eval: false
duplicate = nga$shapeName[nga$shapeName %in% nga$shapeName[duplicated(nga$shapeName)]]

duplicate
```

From the result, there are 12 LGAs that have the same names, even though they are from different states. We will want to rename them or it would be confusing when we conduct further analysis.

Firstly, we create a data frame with the duplicate

```{r}
#| eval: false
nga_dupes = nga %>%
  filter(shapeName %in% duplicate)
```

Calling `ttm()` in the **tmap** package will switch the tmap's viewing mode to interactive viewing, which will help us find the states of the respective duplicates in the map. We then plot the map with **tmap** functions

```{r}
#| eval: false
tm_shape(nga_dupes) + 
  tm_polygons("shapeName") +
  tm_borders(alpha=0.5) 

```

From the result, we can observe the following:

| shapeID                    | shapeName           |
|----------------------------|---------------------|
| NGA-ADM2-72505758B95534398 | Bassa (Kogi)        |
| NGA-ADM2-72505758B52690633 | Bassa (Plateau)     |
| NGA-ADM2-72505758B26581542 | Ifelodun (Kwara)    |
| NGA-ADM2-72505758B18326272 | Ifelodun (Osun)     |
| NGA-ADM2-72505758B75034141 | Irepodun (Kwara)    |
| NGA-ADM2-72505758B79178637 | Irepodun (Osun)     |
| NGA-ADM2-72505758B6786568  | Nasarawa (Kano)     |
| NGA-ADM2-72505758B67188591 | Nasarawa (Nasarawa) |
| NGA-ADM2-72505758B7318634  | Obi (Benue)         |
| NGA-ADM2-72505758B3073896  | Obi (Nasarawa)      |
| NGA-ADM2-72505758B6675111  | Surulere (lagos)    |
| NGA-ADM2-72505758B31597260 | Surulere (Oyo)      |

Based on the results above, we replace the shape names with shapeID as the identifier and run the duplicate check again to verify that it is now empty

```{r}
#| eval: false
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B95534398'] = 'Bassa (Kogi)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B52690633'] = 'Bassa (Plateau)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B26581542'] = 'Ifelodun (Kwara)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B18326272'] = 'Ifelodun (Osun)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B75034141'] = 'Irepodun (Kwara)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B79178637'] = 'Irepodun (Osun)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B6786568'] = 'Nasarawa (Kano)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B67188591'] = 'Nasarawa (Nasarawa)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B7318634'] = 'Obi (Benue)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B3073896'] = 'Obi (Nasarawa)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B6675111'] = 'Surulere (lagos)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B31597260'] = 'Surulere (Oyo)'

duplicate = nga$shapeName[nga$shapeName %in% nga$shapeName[duplicated(nga$shapeName)]]

duplicate
```

Once we are done, we simply remove the unnecessary columns and keep only *shapeName* and save the data frame with `saveRDS()`

```{r}
#| eval: false
nga = nga %>%
  select(shapeName)

saveRDS(nga, "data/geospatial/nga_ex2.rds")
```

We can then retrieve the cleaned RDS file using `readRDS()` and the set view mode to interactive using `ttm()`

```{r}
nga = readRDS("data/geospatial/nga_ex2.rds")
ttm()
```

## Aspatial Data

### Cleaning the Data

The aspatial dataset used in this assignment is the water point data exchange dataset found in [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/). Data is filtered on the web portal to only keep Nigeria and the file is saved as *NigeriaWaterPoints_Raw.csv*

As we are only interested in the functionality of the water point, it is important to capture fields that may may aid us in our analysis (Definition are found here: [Source](https://data.waterpointdata.org/dataset/Water-Point-Data-Exchange-Plus-WPdx-/eqje-vguj))

-   LGA: The area we are interested in

-   State: The state of the LGA of Nigeria

-   Functional: Whether it is functional or not

-   Management: who manages it?

-   Quality: what is the quality?

-   Water Source Category: where the water came from?

-   Water Tech Category: What technology is used?

-   is_urban: Is it in an urban area?

-   #distance_to_primary_road: Based on calculations with data from OpenStreetMap, the distance in km to the nearest road.

-   #distance_to_secondary_road: Based on calculations using OpenStreetMap data, the distance in km to the second-closest road.

-   #distance_to_tertiary_road: Using calculations with data from OpenStreetMap, the distance to the third-closest road is given in km.

-   Usage Capacity: Maximum recommended number of users per waterpoint

-   New Georeferenced Column: : Well Known Text **(wkt)** representing spatial data in a textual format

To load the raw data file, we use the `read_csv` function

```{r}
#| eval: false
wpdx_raw = read_csv("data/aspatial/NigeriaWaterPoints_Raw.csv") 
```

Most of the columns are irrelevant, so we will perform the following:

-   keep the columns we want to clean it up by specifying the columns with one to retain with `subset`

-   renaming the columns using `rename_with`

-   Replace all the NA with unknown for columns with NA value present

```{r}
#| eval: false
retain_cols = c('#clean_adm2', '#clean_adm1', '#status_clean', '#management_clean'
                , '#subjective_quality', '#water_source_category', 
                '#water_tech_category', 
                'New Georeferenced Column', 'is_urban','#distance_to_primary_road',
                '#distance_to_secondary_road', '#distance_to_tertiary_road'
                ,'usage_capacity')

new_col_names = c('LGA', 'State', 'Functional', 'Management', 
                  'Quality',  'Water_Source_Category', 'Water_Tech_Category',
                  'WKT', 'Is_Urban_Area', 'dist_to_primary_road'
                  ,'dist_to_secondary_road', 'dist_to_tertiary_road'
                  ,'usage_capacity')

wpdx_clean = subset(wpdx_raw, select = (names(wpdx_raw) %in% retain_cols)) %>%  rename_with(~ new_col_names, all_of(retain_cols)) %>% 
replace_na(list(Functional = "Unknown", Management = "Unknown", Quality = "Unknown", Water_Source_Category = "Unknown", Water_Tech_Category = "Unknown"))



```

We save the processed data frame *wpdx_clean* into a file, the file will be reduced to 3.4 MB from the 144 MB raw file that we downloaded.

```{r}
#| eval: false
saveRDS(wpdx_clean, "data/aspatial/wpdx_clean_ex2.rds")
```

We can then delete the raw file from the project and retrieve the saved RDS file using `readRDS()`

```{r}
wpdx_clean = readRDS("data/aspatial/wpdx_clean_ex2.rds")
```

### Converting csv data into spatial features

We can use `st_as_sfc()` to come up with the new field *Geometry* by using the WKT field

```{r}
wpdx_clean$Geometry = st_as_sfc(wpdx_clean$`WKT`)
```

We will then use `st_sf()` to convert the tibble data frame into sf data frame. The EPSG 4326 code is used as the dataset is referencing WGS84 geographic coordinate system.

We could use `st_crs()`to verify the coordinate system from the object.

```{r}
wpdx_clean_sf = st_sf(wpdx_clean, crs=4326) 
st_crs(wpdx_clean_sf)
```

Lastly, the attribute data from the *nga* sf data frame will be transferred into the *wpdx_clean_sf* data frame using a geoprocessing function known as point-in-polygon overlay. `st_join()` from the sf package can help us with that

```{r}
nga_wp = st_join(wpdx_clean_sf, nga)
```

## Exploratory Data Analysis (EDA)

We can use `freq()` of the **funModeling** package to display the distribution of *our data points of interest using wpdx_clean_sf*. This is to help us aggregate the data as the dataset provide breakdowns of their respective catagories.

### Categorical Variables

```{r}
freq(data=nga_wp, input = 'Functional')
```

Checking out functionality, we know that functional water points are broken down into *Functional, Functional but needs repair,* and *Functional but not in use.* 48.29% are functional, 4.82% are functional but needs repair and 1.77% of them are functional but not in use.

```{r}
freq(data=nga_wp, input = 'Management')
```

Checking out water point management, we know that water points are mostly managed except 37.8% which are unknowns

```{r}
freq(data=nga_wp, input = 'Quality')
```

Checking out the quality of water points, we know that 75.57% of them are of acceptable quality, with an additional 0.04% of them within potable national limits / standards. The rest are either unknown or of unacceptable quality.

```{r}
freq(data=nga_wp, input = 'Water_Source_Category')
```

Checking out the source of water points, we know that majority of them (96.35%) comes from well. With such a high number, this variable may not be useful for our analysis as it most of the data points will come have this value.

```{r}
freq(data=nga_wp, input = 'Water_Tech_Category')
```

Checking out the technology the water point uses, we know that water points are broken down into *Hand pumps, Mechanized Pump, Tapstand, Rope and bucket.* 61.84% of water points operates on hand pumps, 26.99% on mechanized pumps, 10.58% are unknowns and a minority of them (less than 0.58%) are either on tapstand or Rope and Bucket.

```{r}
freq(data=nga_wp, input = 'Is_Urban_Area')
```

From the records, only 20.59% of the water points are in urban areas, while the rest of them (79.41%) are in the rural areas.

```{r}
freq(data=nga_wp, input = 'usage_capacity')
```

Majority of the water points caters to 300 people or less (73.1%), while 26.99% of the water points caters to a capacity of 1000 people

### Continuous Variables

We will need to find out the summary of the respective distance in order to categorize them appropriately for analysis. We can achieve that by using summary statistics in R

```{r}
summary(nga_wp$dist_to_primary_road)
```

```{r}
summary(nga_wp$dist_to_secondary_road)
```

```{r}
summary(nga_wp$dist_to_tertiary_road)
```

Based on the results above, we know that the median distance (in km) to primary, secondary and tertiary roads is 6647.50 km, 4446.0 km and 1442.4 km respectively. We can use within median distance to analyze if accessibility to water points is a factor to regionalization

### Aggregate the Data

To aggregate the variable of interest, we will create new data frames to store them by using the `filter` function. Variables names used are self explanatory.

```{r}
#| eval: false
func_list = c("Functional", "Functional but needs repair", "Functional but not in use")
wpt_functional_true = wpdx_clean_sf %>%
  filter(Functional %in% func_list)

wpt_functional_false = wpdx_clean_sf %>%
  filter(!Functional %in% c(func_list, "Unknown"))

wpt_rural = wpdx_clean_sf %>%
  filter(Is_Urban_Area == FALSE)

wpt_handpumps_true = wpdx_clean_sf %>%
  filter(Water_Tech_Category %in% "Hand Pump")

wpt_handpumps_false = wpdx_clean_sf %>%
  filter(!Water_Tech_Category %in% "Hand Pump")

wpt_potable_true = wpdx_clean_sf %>%
  filter(Quality %in% c("Acceptable quality", "Within National standards (potable)
", "Within National limits (potable)"))

wpt_potable_false = wpdx_clean_sf %>%
  filter(!Quality %in% c("Acceptable quality", "Within National standards (potable)
", "Within National limits (potable)", "Unknown"))

wpt_potable_unknown = wpdx_clean_sf %>%
  filter(!Quality %in% "Unknown")

wpt_usageOver1000 = wpdx_clean_sf %>%
  filter(usage_capacity >= 1000)

wpt_usageUnder1000 = wpdx_clean_sf %>%
  filter(usage_capacity < 1000)

wpt_accessibility_PriRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_primary_road < 6647.50)
  
wpt_accessibility_PriRd_moreThanMedian = wpdx_clean_sf %>%
  filter(dist_to_primary_road >= 6647.50)

wpt_accessibility_secRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_secondary_road < 4446.0  )
  
wpt_accessibility_secRd_moreThanMedian = wpdx_clean_sf %>%
  filter(dist_to_secondary_road >= 4446.0  )
  
wpt_accessibility_TerRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_tertiary_road < 1442.4  )
  
wpt_accessibility_TerRd_moreThanMedian = wpdx_clean_sf %>%
  filter(dist_to_tertiary_road >= 1442.4  )

wpt_managed_true = wpdx_clean_sf %>%
  filter(!Management %in% "Unknown")

wpt_managed_unknown = wpdx_clean_sf %>%
  filter(Management %in% "Unknown")
```

### Computing our data points of interest

We can use `st_intersects()` to find common data points between geographical datasets. In our case we need to find the common points in the Nigeria's LGA spatial dataset and the water point aspatial dataset

The below code adds new columns to compute the total number of water points of our data point of interests

As an example, the below code intersects the Nigeria LGA dataset (*nga_wp* dataframe) with the water point dataset (*wpdx_clean_sf* dataframe) and produce a new column to denote the total number of water points in the area (*Total wpt*) by using `mutate()` and `lengths()`

```{r}
#| eval: false
nga_wp = nga %>% 
  #combine nga with water point sf
  mutate(`total wpt` = lengths(
    st_intersects(nga, wpdx_clean_sf)))
```

Similarly, for the rest of the variables, we piped the output and add the new columns to denote the number of

-   water points are functional, non functional and unknown

-   Water points that are in rural areas

-   Water points that either uses Hand pumps or otherwise

-   Water points that have either potable or non potable water

-   Water points with usage capacity of over 1000 persons or under

-   Water points within or over Median distance of Primary, Secondary and Tertiary roads

-   Water points management that are managed

```{r}
#| eval: false
nga_wp = nga %>% 
  #combine nga with water point sf
  mutate(`total wpt` = lengths(
    st_intersects(nga, wpdx_clean_sf))) %>%
  #add columns to produce no. of functional, non functional and unknown points
  mutate(`wpt functional` = lengths(
    st_intersects(nga, wpt_functional_true))) %>%
  mutate(`wpt non functional` = lengths(
    st_intersects(nga, wpt_functional_false))) %>%
  # rural
  mutate(`isRural` = lengths(
    st_intersects(nga, wpt_rural))) %>%
  # hand pumps
  mutate(`Uses Handpumps` = lengths(
    st_intersects(nga, wpt_handpumps_true))) %>%
  # Potable
   mutate(`Potable` = lengths(
    st_intersects(nga, wpt_potable_true))) %>%
  mutate(`Non Potable` = lengths(
    st_intersects(nga, wpt_potable_false))) %>%
  # Usage Capacity
  mutate(`usage Over 1000` = lengths(
    st_intersects(nga, wpt_usageOver1000))) %>%
  mutate(`usage Under 1000` = lengths(
    st_intersects(nga, wpt_usageUnder1000))) %>%
  #Primary Road
  mutate(`Within Median Distance to Pri Road` = lengths(
    st_intersects(nga, wpt_accessibility_PriRd_lessThanMedian))) %>%
  mutate(`Exceed Median Distance to Pri Road` = lengths(
    st_intersects(nga, wpt_accessibility_PriRd_moreThanMedian))) %>%
  #Secondary Road
  mutate(`Within Median Distance to Sec Road` = lengths(
    st_intersects(nga, wpt_accessibility_secRd_lessThanMedian))) %>%
  mutate(`Exceed Median Distance to Sec Road` = lengths(
    st_intersects(nga, wpt_accessibility_secRd_moreThanMedian))) %>%
  #Tertiary Road
  mutate(`Within Median Distance to Ter Road` = lengths(
    st_intersects(nga, wpt_accessibility_PriRd_lessThanMedian))) %>%
  mutate(`Exceed Median Distance to Ter Road` = lengths(
    st_intersects(nga, wpt_accessibility_TerRd_moreThanMedian))) %>%
  #management
  mutate(`Managed` = lengths(
    st_intersects(nga, wpt_managed_true))) 
  
  
```

Once we are done with the raw data, we use the below code to compute the respective percentages

-   percentage of functional water points

-   percentage of non functional water points

-   percentage of water points with hand pumps as technology

-   percentage of water points with potable / non potable water

-   percentage of water points with capacity over/under 1000

-   percentage of water points that are managed

-   percentage of water points in rural areas

-   percentage of water points are within the median distance to primary road network

-   percentage of water points are within the median distance to secondary road network

-   percentage of water points are within the median distance to tertiary road network

```{r}
#| eval: false
nga_wp = nga_wp %>%
  #add columns to compute %
  mutate(`pct_functional` = `wpt functional`/`total wpt`) %>%
  mutate(`pct_non-functional` = `wpt non functional`/`total wpt`) %>%

  mutate(`pct_Handpump` = `Uses Handpumps`/`total wpt`) %>%

  mutate(`pct_Potable` = `Potable`/`total wpt`) %>%
  mutate(`pct_NonPotable` = `Non Potable`/`total wpt`) %>%
  
  mutate(`pct_Cap_Over_1000` = `usage Over 1000`/`total wpt`) %>%
  mutate(`pct_Cap_Under_1000` = `usage Under 1000`/`total wpt`) %>%
    
  mutate(`pct_managed` = `Managed`/`total wpt`) %>%
  mutate(`pct_rural` = `isRural`/`total wpt`) %>%
  
  mutate(`pct_w_meddist_to_PriRoad` = `Within Median Distance to Pri Road`/`total wpt`) %>%
  
  mutate(`pct_w_meddist_to_SecRoad` = `Within Median Distance to Sec Road`/`total wpt`) %>%
  
  mutate(`pct_w_meddist_to_TerRoad` = `Within Median Distance to Ter Road`/`total wpt`) 
```

After we are done, we will inspect the data by viewing the data frame, we can observe that there are some rows that have NaN due to division by zero. Lets replace those values to 0 with the `is.na()` function and change the row names to the names of the LGAs with `row.names()` by using the code below

```{r}
#| eval: false
nga_wp[is.na(nga_wp)] = 0
row.names(nga_wp) = nga_wp$shapeName
```

We will only keep the following variables as the rest are intermediate data points that are no longer relevant

1.  wpt functional

2.  wpt non functional

3.  pct_functional

4.  pct_non-functional

5.  pct_Handpump

6.  pct_Potable

7.  pct_NonPotable

8.  pct_Cap_Over_1000

9.  pct_Cap_Under_1000

10. pct_managed

11. pct_rural

12. pct_w\_meddist_to_PriRoad

13. pct_w\_meddist_to_SecRoad

14. pct_w\_meddist_to_TerRoad

```{r}
#| eval: false
nga_wp_interested_data_pts = nga_wp  %>% 
      select(4:5, 19:30) 
```

We save the processed data frame *nga_wp_interested_data_pts* into a file with `saveRDS()`, so that we do not need to process it again

```{r}
#| eval: false
saveRDS(nga_wp_interested_data_pts, "data/geospatial/nga_wp_interested_data_pts.rds")
```

We can then retrieve the saved RDS file using `readRDS()`

```{r}
nga_wp_interested_data_pts = readRDS("data/geospatial/nga_wp_interested_data_pts.rds")
```

### EDA using statistical graphics

A Histogram is useful to identify the overall distribution of the data values (i.e. positively skew, negatively skew or normal distribution)

We use **ggplot2**'s histogram (`geom_histogram`) to plot the percentage functional and non functional water points with the mean and median as abline using `geom_vline()`

We plot them side by side using `ggarrange`

```{r}
functional_pct_histo = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$pct_functional)),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$pct_functional)),   
               color="brown", linetype="dashed", linewidth=1)

nonfunctional_pct_histo = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_non-functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Non Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_non-functional` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_non-functional`)),   
               color="brown", linetype="dashed", linewidth=1)


ggarrange(functional_pct_histo, nonfunctional_pct_histo, ncol = 2, nrow = 1)

```

From the result, we can observe that both functional and non functional water points distributions are positively skewed. The functional water point mean and median is close to 50%, whereas the non functional water points median and mean are very close to each other at 35.05% and 35.92% respectively

We can also use box plot to detect outliers with `geom_boxplot`. We plot them side by side using `ggarrange`

```{r}
functional_boxplot = ggplot(data=nga_wp_interested_data_pts, 
       aes(x=`pct_functional`)) +
       labs(x = "% Functional") +
       geom_boxplot(color="black", fill="light blue")

nonfunctional_boxplot = ggplot(data=nga_wp_interested_data_pts, 
       aes(x=`pct_non-functional`)) + 
       labs(x = "% Non Functional") +
       geom_boxplot(color="black", fill="light blue") 
  

ggarrange(functional_boxplot, nonfunctional_boxplot, ncol = 2, nrow = 1)
```

We can see that there isn't any outliers in the functional water points, but for the non functional water points, there is an outlier where 100% of the water points are not functional.

In the figure below, multiple histograms are plotted to reveal the distribution of the selected variables in the *nga_wp_interested_data_pts* data.frame. First, We do this by creating all the histograms assigned to individual variables.

```{r}

functional = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `wpt functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "No. of Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`wpt functional`)), 
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`wpt functional`)), color="brown", linetype="dashed", linewidth=1)

nonfunctional = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `wpt non functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "No. of Non Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`wpt non functional` )),color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`wpt non functional`)),color="brown", linetype="dashed", linewidth=1)

functional_pct = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_functional` )),color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_functional`)), color="brown", linetype="dashed", linewidth=1)

nonfunctional_pct = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_non-functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Non Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_non-functional` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_non-functional`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_Handpump = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_Handpump`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Handpump", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Handpump` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Handpump`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_Potable = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_Potable`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Potable", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Potable` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Potable`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_NonPotable = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_NonPotable`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Non Potable", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_NonPotable` )),   color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_NonPotable`)),    color="brown", linetype="dashed", linewidth=1)


pct_Usage_Capacity_Over_1000 = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_Cap_Over_1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Usage capacity >= 1000", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Cap_Over_1000` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Cap_Over_1000`)),   
               color="brown", linetype="dashed", linewidth=1)


pct_Usage_Capacity_Under_1000 = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_Cap_Under_1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Usage capacity < 1000", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Cap_Under_1000` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Cap_Under_1000`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_managed = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_managed`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Managed", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_managed` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_managed`)),   
               color="brown", linetype="dashed", linewidth=1)


pct_rural = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_rural`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(x = "% Rural", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_rural` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_rural`)),   
               color="brown", linetype="dashed", linewidth=1)


pct_within_median_dist_to_pri_road = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_w_meddist_to_PriRoad`)) +
              geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
                labs(x = "% Rural", y = "Frequency") +
                geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_PriRoad` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_PriRoad`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_within_median_dist_to_sec_road = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_w_meddist_to_SecRoad`)) +
              geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
                labs(x = "% Rural", y = "Frequency") +
                geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_SecRoad` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_SecRoad`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_within_median_dist_to_ter_road = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_w_meddist_to_TerRoad`)) +
              geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
                labs(x = "% Rural", y = "Frequency") +
                geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_TerRoad` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_TerRoad`)),   
               color="brown", linetype="dashed", linewidth=1)


ggarrange(functional, nonfunctional, 
          functional_pct, nonfunctional_pct,
          ncol = 2, nrow = 2)

ggarrange(pct_Potable, pct_NonPotable, 
          pct_Usage_Capacity_Over_1000, pct_Usage_Capacity_Under_1000,
          pct_managed, pct_rural,
          ncol = 2, nrow = 3)
          

ggarrange(pct_within_median_dist_to_pri_road, 
          pct_within_median_dist_to_sec_road, 
          pct_within_median_dist_to_ter_road, 
          pct_Handpump,
          ncol = 2, nrow = 2)


```

From the charts, we can observe that

-   No. of functional water points & non functional water points are positively skewed

-   percentage of functional follows closely to a normal distribution while percentage of non functional is positively skewed

-   percentage of water points with potable water is negatively skewed while percentage of water points with non potable water is positively skewed

-   percentage of water points with usage capacity over 1000 is positively skewed while percentage of water points with usage capacity less than 1000 is negatively skewed

-   percentage of managed water points is negatively skewed

-   percentage of rural water points is negatively skewed

-   percentage of water points with primary road within median distance is negatively skewed

-   percentage of water points with secondary road within median distance is negatively skewed

-   percentage of water points with tertiary road within median distance is negatively skewed

-   percentage of water points with hand pumps is negatively skewed.

> *As functional and non functional water points are **NOT** of the same units as the other variables in percentage, we will need to normalize it later.*

### Visualizing the spatial distribution of water points

We will plot the map with the **tmap** package. In this exercise we will use the *jenks* style as it looks for clusters of related values and highlights the differences between categories. (Nowosad, 2019)

```{r}
nga_wp_interested_data_pts.map.pct_func = 
  tm_shape(nga_wp_interested_data_pts) + 
  tm_fill("pct_functional", 
          palette ="PuRd", style="jenks", n = 5) +  
  tm_borders(alpha=0.5) + 
  tm_grid (alpha=0.2) +
  tm_layout(main.title="% functional WP", 
            main.title.position="center", 
            main.title.size=0.8, 
            frame = TRUE) 
 
nga_wp_interested_data_pts.map.pct_nonfunc = 
  tm_shape(nga_wp_interested_data_pts) + 
  tm_fill("pct_non-functional", 
          palette ="PuRd", style="jenks", n = 5) +  
  tm_borders(alpha=0.5) + 
  tm_grid (alpha=0.2) +
  tm_layout(main.title="% non functional WP", 
            main.title.position="center", 
            main.title.size=0.8, 
            frame = TRUE) 

tmap_arrange(nga_wp_interested_data_pts.map.pct_func, nga_wp_interested_data_pts.map.pct_nonfunc, asp=1, ncol=2)
```

From the results, we can observe the following:

-   The north east area of Nigeria have little to no water point at all

-   Functional water points congregate in the northern side of the country

-   Non functional water points congregates around the south western coast of Nigera, facing gulf of Guinea & Bight of Benin.

## Correlation Analysis

### Finding Correlated Variables

It is important that we ensure the cluster variables are not highly correlated before we conduct cluster analysis.

We will first remove the geometry object from the data frame using `st_set_geometry(NULL)`

```{r}
nga_wp_corr_vars = nga_wp_interested_data_pts %>%
          st_set_geometry(NULL)
```

We will use `corrplot.mixed()` ([ref](https://cran.r-project.org/web/packages/corrplot/corrplot.pdf)) function of the [**corrplot**](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html) package. However we need to find the correlation matrix first with `cor()`

```{r}
#| eval: false
cluster_vars.cor = cor(nga_wp_corr_vars) 

q = corrplot.mixed(cluster_vars.cor, 
               lower = "ellipse", 
               upper = "number", 
               tl.pos = "lt", 
               diag="l", 
               tl.col="black")

```

![](corr_matrix.png){fig-align="center"}

According to Calkins (2005), variables that can be regarded as having a high degree of correlation are indicated by correlation coefficients with magnitudes between 0.7 and 1.0. As such, the following **5 observations** are highly correlated from the results

1.  pct_functional - Percentage of functional water points

2.  pct_handpump - percentage of water points with hand pumps

3.  pct_potable - Percentage of water points with potable water

4.  pct_Cap_Over_1000 - percentage of water points with capacity over 1000

5.  pct_w\_meddist_to_PriRoad - percentage of water points within median distance of a primary road

In view of that we will just keep pct_functional and drop the other 4 by using the `select` statement

```{r}
nga_wp_corr_vars = nga_wp_corr_vars %>%
                   select(1:4, 7, 9:11, 13:14)
```

### Data Standardization

As most of the data points are already in percentages except the number of functional and non functional water points, we will need to perform standardization so that they will be comparable. From the histogram generated previously, we know that not all of the variables follow some normal distribution, so we will use Min-Max normalization instead.

To achieve that we can use the [**heatmaply**](https://cran.r-project.org/web/packages/heatmaply/) package's `normalize()` function. The `summary()` function is used to show the summary statistics for the standardized clustering variables.

```{r}
nga_wp_corr_vars.std_minmax = normalize(nga_wp_corr_vars)
summary(nga_wp_corr_vars.std_minmax)
```

The values range of the Min-max standardized clustering variables are between 0 and 1 now.

#### Visualizing the standardize clustering variables

It is a good idea to visualize the distribution graphical of the standardized clustering variables in addition to evaluating the summary statistics of those variables.

```{r}
r_func = ggplot(data=nga_wp_interested_data_pts, aes(x=`wpt functional`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`wpt functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`wpt functional`)),   
               color="brown", linetype="dashed", linewidth=1)

s_func = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`wpt functional`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`wpt functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`wpt functional`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_nfunc = ggplot(data=nga_wp_interested_data_pts, aes(x=`wpt non functional`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Non Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`wpt non functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`wpt non functional`)),   
               color="brown", linetype="dashed", linewidth=1)

s_nfunc = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`wpt non functional`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Non Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`wpt non functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`wpt non functional`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

ggarrange(r_func, s_func, r_nfunc, s_nfunc,
          ncol = 2,
          nrow = 2)
```

```{r}
r_pctFunc = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_functional`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "% Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_functional`)),   
               color="brown", linetype="dashed", linewidth=1)

s_pctFunc = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_functional`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "% Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_functional`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_pctNfunc = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_non-functional`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "% Non Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_non-functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_non-functional`)),   
               color="brown", linetype="dashed", linewidth=1)

s_pctNfunc = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_non-functional`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "% Non Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_non-functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`wpt non functional`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

ggarrange(r_pctFunc, s_pctFunc, r_pctNfunc,s_pctNfunc,
          ncol = 2,
          nrow = 2)
```

```{r}
r_nonpotable = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_NonPotable`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Non Potable", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_NonPotable`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_NonPotable`)),   
               color="brown", linetype="dashed", linewidth=1)

s_nonpotable = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_NonPotable`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Non Potable", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_NonPotable`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_NonPotable`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_capUnder1000 = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_Cap_Under_1000`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Usage Capacity < 1000", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Cap_Under_1000`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Cap_Under_1000`)),   
               color="brown", linetype="dashed", linewidth=1)

s_capUnder1000 = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_Cap_Under_1000`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Usage Capacity < 1000", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_Cap_Under_1000`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_Cap_Under_1000`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

ggarrange(r_nonpotable, s_nonpotable, r_capUnder1000, s_capUnder1000 ,
          ncol = 2,
          nrow = 2)
```

```{r}
r_Managed = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_managed`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Managed", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_managed`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_managed`)),   
               color="brown", linetype="dashed", linewidth=1)

s_Managed = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_managed`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Managed", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_managed`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_managed`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_rural = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_rural`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Rural", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_rural`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_rural`)),   
               color="brown", linetype="dashed", linewidth=1)

s_rural = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_rural`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Rural", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_rural`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_rural`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

ggarrange(r_Managed, s_Managed, r_rural, s_rural ,
          ncol = 2,
          nrow = 2)
```

```{r}
r_w_dist_toSecRoad = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_w_meddist_to_SecRoad`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Within Dist to Secondary Road", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_SecRoad`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_SecRoad`)),   
               color="brown", linetype="dashed", linewidth=1)

s_w_dist_toSecRoad = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_w_meddist_to_SecRoad`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Within Dist to Secondary Road", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_w_meddist_to_SecRoad`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_w_meddist_to_SecRoad`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_w_dist_toTerRoad = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_w_meddist_to_TerRoad`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Within Dist to Tertiary Road", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_TerRoad`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_TerRoad`)),   
               color="brown", linetype="dashed", linewidth=1)

s_w_dist_toSecRoad = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_w_meddist_to_TerRoad`)) + 
    geom_histogram(bins=20, color="black", fill="light blue") +
    labs(x = "Within Dist to Tertiary Road", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_w_meddist_to_TerRoad`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_w_meddist_to_TerRoad`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

ggarrange(r_w_dist_toSecRoad , s_w_dist_toSecRoad, r_w_dist_toTerRoad , s_w_dist_toSecRoad,
          ncol = 2,
          nrow = 2)
```

After observing the histograms, we can conclude that the distribution did not change for all of the variables. preserving the nature of the data post standardization.

#### Determine the proximity matrix.

With R's `dist()` function, we shall compute the proximity matrix. The six distance proximity calculations that are supported by `dist()` are the euclidean, maximum, manhattan, canberra, binary, and minkowski methods. As the variables are largely dissimilar, we use the *minkowski* method

```{r}
proxmat = dist(nga_wp_corr_vars.std_minmax, method="minkowski")
proxmat 
```

### Computing hierarchical clustering

Hierarchical clustering is an unsupervised machine learning technique that divides objects into clusters based on how related they are. The result is a collection of clusters, each of which differs from the others while having things that are generally similar to one another.

A tree-like diagram known as a dendrogram is used to record the sequences of mergers and splits in the result of the clustering process.

We can use `hclust()` method provided by the R Stat class to find our clusters with our proximity matrix we found earlier using the *ward.d* method. The dendrogram is drawn using `plot()` of R graphics

```{r}
#| fig.height = 10, fig.width = 10
hclust_ward_d = hclust(proxmat, method="ward.D")
q = plot(hclust_ward_d, cex=0.5) 
```

#### Selecting the optimal clustering algorithm

Finding stronger clustering structures is a challenge when performing hierarchical clustering. Using the `agnes()` function of the **cluster** package will address the issue.

It performs similar operations to `hclus()`, but `agnes()` also provides the agglomerative coefficient, which gauges the degree of clustering structure present

> ***values closer to 1 suggest strong clustering structure***

We define the different methods and name of them in the variable *m* and define a function to find the agglomerative coefficient (*ac*). By calling `map_dbl(m, ac)` we can iterate through the list to find the respective ac of the different functions

```{r}
m = c("average", "single", "complete", "ward")
names(m) = c("average", "single", "complete", "ward")

ac = function(y) {
  agnes(nga_wp_corr_vars.std_minmax, method=y)$ac
}

map_dbl(m,ac)
```

According to the results shown above, Ward's approach offers the greatest clustering structure out of the four examined methods as it is closest to 1. Consequently, only Ward's technique will be applied in the analysis that follows.

### Determining Optimal Clusters

The choice of the best clusters to keep is a technical problem for data analysts when undertaking clustering analysis.

The gap statistic contrasts the overall intra-cluster variation for various values of *k* with the values that would be predicted under a null reference distribution for the data.

The value that maximizes the gap statistic will be used to estimate the best clusters (i.e., that yields the largest gap statistic). In other words, the clustering structure is very different from a randomly distributed, uniform distribution of points.

To compute the gap statistic, [`clusGap()`](https://www.rdocumentation.org/packages/cluster/versions/2.1.0/topics/clusGap) of [**cluster**](https://cran.r-project.org/web/packages/cluster/) package will be used. with the [`hcut`](https://rpkgs.datanovia.com/factoextra/reference/hcut.html) function from [**factoextra**](https://rpkgs.datanovia.com/factoextra/) package.

```{r}
set.seed(12345)
gap_stat = clusGap(nga_wp_corr_vars.std_minmax, FUN=hcut, nstart=25, K.max = 10, B = 50)
# Print the result
print(gap_stat, method = "firstmax")
```

Next, we can visualise the plot by using [`fviz_gap_stat()`](https://rpkgs.datanovia.com/factoextra/reference/fviz_nbclust.html) of [**factoextra**](https://rpkgs.datanovia.com/factoextra/) package.

```{r}
fviz_gap_stat(gap_stat)
```

We can infer from the figure above that **10** clusters is the optimum number for the Hierarchical Clustering Algorithm.

Using **R stats'** `rect.hclust()` function, the dendrogram can alternatively be plotted with a border around the chosen clusters. The rectangles' borders can be colored using the option border.

```{r}
#| fig.height = 10, fig.width = 10
plot(hclust_ward_d, cex=0.6)
rect.hclust(hclust_ward_d, k = 10, border = 2:10)
```

### Visually-driven hierarchical clustering analysis

By using [**heatmaply**](https://cran.r-project.org/web/packages/heatmaply/) package we are able to build both highly interactive cluster heatmap or static cluster heatmap.

```{r}
nga_wp_corr_vars.std_minmax_mat = data.matrix(nga_wp_corr_vars.std_minmax)
```

Plotting interactive cluster heatmap using `heatmaply()`

```{r}
heatmaply(normalize(nga_wp_corr_vars.std_minmax_mat), 
          Colv=NA,
          dist_method = "minkowski",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors=PuRd,
          k_row = 10,
          margins= c(NA, 200, 60, NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main = "Segmentation of Nigeria water points",
          xlab = "Water point indicators",
          ylab = "Nigeria LGA"
          
          )
```

### Mapping the clusters formed in hierarchical clustering

Following a thorough analysis of the dendragram shown above, we chose to keep 20groups. The code below will use R Base's `cutree()` function to create a 10-cluster model.

```{r}
groups = as.factor(cutree(hclust_ward_d, k=10))
```

Groups are the output. It is a *list* object.

The groups object needs to be added to the *nga* simple feature object in order to visualize the clusters.

The following code snippet forms the join in 3 steps:

1.  The object representing the groups list will be transformed into a matrix;

2.  *nga* is appended with the groups matrix using `cbind()` to create the simple feature object *nga_wp_cluster*;

3.  The as.matrix.groups column is renamed to CLUSTER using the **dplyr** package's `rename()` function.

```{r}
nga_wp_cluster = cbind(nga, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

Next we use the tmap functions to plot the cloropleth map showing the clusters

```{r}
hclust_map_without_spatial_constraints = tm_shape(nga_wp_cluster) + 
  tm_layout(main.title="Distribution of H Clusters", 
            main.title.position="center", 
            main.title.size=0.9, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) + 
  tm_polygons("CLUSTER") +
  tm_borders(alpha = 0.5) 

hclust_map_without_spatial_constraints
```

We can see that without spatial constraints, the map generated 10 clusters that are quite messy and the regions forming the clusters are all over the place. This is sub optimal as there may be real world consideration that necessitates the regionalization of geographies into distinct regions, such as urban planning.

## Spatially Constrained Clustering

Now that we know utilizing overarching clustering without spatial considerations can form fragmented clusters that are not optimal, lets looks at adding spatial constraints

### SKATER approach

We will use the `skater()` method of the **spdep** package to derive a geographically limited cluster in this section.

The SKATER approach is a method that begins with a set of edges, a data set and a number of cuts to determine clusters.

1.  First We must first transform *nga* into a spatial polygons data frame. This is because only SP objects (*SpatialPolygonDataFrame*) are supported by the SKATER function.

```{r}
nga_sp = as_Spatial(nga)
```

#### Computing Neighbour List

The neighbours list from the polygon list will then be computed using the `poly2nb()` function of the **spdep** package.

```{r}
nga_sp.nb = poly2nb(nga_sp)
summary(nga_sp.nb)
```

From the output, there are 774 LGAs in Nigeria, Using the Queen's method, 1 of them has 14 neighbours, 1 of them is an island (no neighbour), and 2 of them only has 1 neighbour

We must first create the weights matrix after determining the spatial weights. A isolated island can be found in the neighbor list's results. Since this island won't have any neighbors at all, it is not recommended to utilize a contiguity weight matrix. In light of this, we'll employ a weight matrix based on distance instead.

#### Building the weights matrix

The distance-based weight matrix can be found by using the **spdep** package's `dnearneigh()` function. The function searches for neighbors of region points using the Euclidean distance between the bottom (\>=) and upper (\<=) bounds or by using the longlat = True parameter and the great circle distance in kilometers.

As there is an island involved, we will build an adaptive weight matrix instead.

Using the k nearest neighbor (knn) technique, we can adjust how many neighbors each LGA has. As discussed in class, we set k in this instance to 8. The R functions used in this case are `knn2nb()` and `knearneigh()`

For distance based matrix, we will need to perform st_transform first, and recreate the nga_sp for the *SpatialPolygonDataFrame*

```{r}
nga_local = st_transform(nga, crs=26392)
st_crs(nga_local)

nga_sp = as_Spatial(nga_local)
```

Before we can start building the matrix, we first need to find the coordinates

-   The longitude is the first variable in each centroid, this enables us to obtain only the longitude.

-   The latitude is the second variable in each centroid, this enables us to obtain only the latitude

-   Using the double bracket notation \[\[\]\] and the index, we can access the latitude & longitude values.

-   After getting the longitude and latitudes values, we can form the coordinates object named `coord` using `cbind`.

```{r}
longitude = map_dbl(nga_local$geometry, ~st_centroid(.x)[[1]]) #longitude index 1
latitude = map_dbl(nga_local$geometry, ~st_centroid(.x)[[2]]) #latitude index 2
coord = cbind(longitude, latitude)
```

We then run the algorithm to create the adaptive distance matrix using `knn2nb()` and `knearneigh()`

```{r}
knn8 = knn2nb(knearneigh(coord, k=8, longlat = FALSE))
str(knn8)
```

#### Computing minimum spanning tree

**Calculating edge costs**

The cost of each edge is determined using `nbcosts()` from the **spdep** package. Its nodes are separated by this distance. This function uses a data.frame with observations vectors in each node to calculate the distance.

```{r}
lcosts = nbcosts(knn8, nga_wp_corr_vars.std_minmax_mat)
```

Next, in a manner similar to how we calculated the inverse of distance weights, we will include these costs into a weights object. In other words, we specify the recently computed *lcosts* as the weights in order to transform the neighbour list into a list weights object. To accomplish this, we can use using the `nb2listw()` function of **spdep** package. We will use the 'B' Style as it will be more robust

```{r}
nga_wp_corr_vars.std_minmax_mat.w = nb2listw(knn8, lcosts, style="B")
summary(nga_wp_corr_vars.std_minmax_mat.w)
```

**Finding the minimum spanning tree**

A minimum spanning trees is a graph where all the vertices are connected by weighted edges with no cycle with the minimum cost.

The minimum spanning tree is computed by using [`mstree()`](https://r-spatial.github.io/spdep/reference/mstree.html) of **spdep** package as shown in the code below. We can check its class and dimensions by using `class()` and `dim()`

```{r}
nga_wp_mst = mstree(nga_wp_corr_vars.std_minmax_mat.w)
class(nga_wp_mst)
dim(nga_wp_mst)
```

The MST plot method includes a mechanism to display the nodes' observation numbers in addition to the edge. We once again plot these along with the LGA lines. We can see how the initial neighbor list is condensed to a single edge that passes through every node

```{r}
#| fig.height = 10, fig.width = 10
plot(nga_sp, border=gray(0.6))
plot.mst(nga_wp_mst, coordinates(nga_sp), col="blue", 
         cex.lab=0.7, cex.circles=0.05, add=TRUE)
```

#### Computing spatially constrained clusters using SKATER method

We can compute the spatially constrained cluster using [`skater()`](https://r-spatial.github.io/spdep/reference/skater.html) of the **spdep** package.

Required inputs for the `skater()` function. 

-   Data matrix (to update the costs while units are being grouped),

-   the number of cuts (no. of variables - 1)

-   the first two columns of the MST matrix

```{r}
clust10 = skater(edge=nga_wp_mst[,1:2], #1st 2 col of MST
                data = nga_wp_corr_vars, #data matrix
                method = "minkowski",
                ncuts = 9 #number of cuts
                )
```

We can display the content of the result using `str()`

```{r}
str(clust10)
```

Finally, we can also plot the pruned tree that shows the 10 clusters on top of the LGA area.

```{r}
#| fig.height = 20, fig.width = 20
plot(nga_sp, border=gray(.5))
plot(clust10,
     coordinates(nga_sp),
     cex.lab=0.5,
     groups.colors=c("red","green","blue", "brown", "orange", "darkgreen", "darksalmon", "gold2", "orchid", "tan3"),
     cex.circles=0.005, 
     add=TRUE
     )
```

#### Visualizing the clusters in choropleth map

The code below is used to plot the newly derived clusters by using the SKATER method

```{r}
groups_mat = as.matrix(clust10$groups)
nga_wp_spatialcluster = cbind(nga_wp_cluster, as.factor(groups_mat)) %>% 
  rename(`SP_CLUSTER` = `as.factor.groups_mat.`)

skatermap = tm_shape(nga_wp_spatialcluster) + 
  tm_layout(main.title="Distribution of clusters with SKATER", 
            main.title.position="center", 
            main.title.size=0.9, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) + 
  tm_fill("SP_CLUSTER") +
  tm_borders(alpha = 0.5) 

skatermap
```

We can observe that once we added spatial constraints into the formula, it is now 10 clusters that are mostly contiguous. This can help us make better decisions on what to do with each cluster and make planning easier when we need to consolidate resources.

The remarkable clusters are:

-   in the north eastern and eastern borders of Nigeria, where there are little to no water points,

-   the west of Nigeria and the south western coast facing gulf of guinea and Bight of Benin where non functional water points congregate

-   North of Nigeria where functional points congregate

### Spatially Constrained Clustering - ClustGeo Method

Another method of introducing spatial constraints to the SKATER algorithm (Spatial 'K'luster Analysis by Tree Edge Removal) (Assuncao & Krainski (n.d)).

This function starts with a set of edges, an input dataset and a number of cuts to form clusters that are homogeneous

In this part of the exercise, we use of the `hclustgeo()` function from the **ClustGeo** package to perform Ward-style hierarchical clustering.

First we will need to create the nongeo_cluster using hclustgeo with the proximity matrix we created in the previous section and we plot its corresponding Dendrogram

```{r}
#| fig.height = 10, fig.width = 10
nongeo_cluster = hclustgeo(proxmat)
plot(nongeo_cluster, cex=0.5)
rect.hclust(nongeo_cluster, k=10, border = 2:9)
```

#### Mapping the clusters formed

Similarly, by applying the techniques we discovered in the section *Mapping the clusters formed in hierarchical clustering,* we may plot the clusters on a categorical area shaded map.

```{r}
groups = as.factor(cutree(nongeo_cluster, k=10))

nga_ngeo_cluster = cbind(nga, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)

default_ngeo_clustered_map = tm_shape(nga_ngeo_cluster) + 
   tm_layout(main.title="Distribution of clusters with HClustGeo", 
            main.title.position="center", 
            main.title.size=0.9, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) + 
  tm_polygons("CLUSTER") +
  tm_borders(alpha = 0.5) 

default_ngeo_clustered_map
```

Without spatial limitations, the map generated 10 clusters that are rather messy and the regions composing the clusters are dispersed throughout the map, which is sub-optimal. This is similar to the results we applied in the section *Mapping the clusters formed in hierarchical clustering*.

#### Spatially Constrained Hierarchical Clustering

Prior to starting the spatially constrained hierarchical clustering process, a spatial distance matrix will need to be derived by using [`st_distance()`](https://r-spatial.github.io/sf/reference/geos_measures.html) of **sf** package.

```{r}
dist = st_distance(nga, nga)
```

`as.dist()` is used to convert the data frame into a matrix.

```{r}
distmat <- as.dist(dist)
```

Our goal is to as much as possible **retain the attribute homogeneity** as much as possible but also **introduce spatial homogeneity**. In order to balance this, we can compute ***∝*** using the `choicealpha()` function.

```{r}
cr = choicealpha(proxmat, distmat, range.alpha = seq(0,1, 0.05), K=10, graph=T)
```

As the data is skewed as we have explored in our EDA, we will use the QNorm graph based on normalized values.

We can observe that when ***∝*** is raised from 0.2 to 0.4, the homogeneity of d1 (which is our spatial relationship (contiguity matrix), gain significantly from about 60% to slightly less than 80%. And for d0 (which is our attribute), the homogeneity loss is at 20%. Since ***∝ = 0.4*** is the most optimal, we will use it to form our cluster.

```{r}
clustG = hclustgeo(proxmat, distmat, alpha = 0.4)
```

We then use `cutree()` to derive the cluster object, and join it back to the *nga* polygon feature data frame by using `cbind()`

```{r}
groups = as.factor(cutree(clustG, k=10))
nga_Gcluster  = cbind(nga, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

We can now plot the map of the newly delineated spatially constraints clusters using functions of **tmap**

```{r}
g_clustered_map = 
  tm_shape(nga_Gcluster) + 
     tm_layout(main.title="Distribution of clusters with HClustGeo using choice alpha", 
            main.title.position="center", 
            main.title.size=0.9, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) + 
  tm_polygons("CLUSTER") +
  tm_borders(alpha = 0.5) 

g_clustered_map
```

Similarly to the SKATER method, we can observe that once we added alpha into the formula, it is now 10 clusters that are mostly contiguous. This can help us make better decisions on what to do with each cluster and make planning easier when we need to consolidate resources.

## Conclusion

We attempt to conclude by plotting the 4 maps together

```{r}
tmap_arrange(hclust_map_without_spatial_constraints,skatermap, 
             ncol = 2, nrow = 1, asp = 1)

tmap_arrange(default_ngeo_clustered_map, g_clustered_map, 
             ncol = 2, nrow = 1, asp = 1)
```

Based on the results, we can see that hierarchical clustering without spatial constraints produces clusters that are messy with no contiguity which is sub optimal in both methods if resources must be focused amongst similar areas.. It will be difficult to conduct planning without spatial considerations.

We can see that the SKATER map generated a map that assumed that the bulk of the water points were homogeneous, creating a relatively large cluster in cluster 1. Due to the size of the cluster, this may not be the right approach for this data set. This is evident from the map generated below. The area in cluster 1 is unlikely to be homogeneous

```{r}

tmap_arrange(nga_wp_interested_data_pts.map.pct_func, nga_wp_interested_data_pts.map.pct_nonfunc, asp=1, ncol=2)
```

The ClustGeo approach produced a much more optimal result as it was able to clearly separate out distinct areas as compared to the SKATER method.

For example

-   the north eastern and eastern borders which contains little to no water points is a large cluster on its own with some small clusters within.

-   The northern part of Nigeria which has most of the functional water points, form a clusters on its own

-   The southern and south western coast of Nigeria, formed 2 main clusters facing the Bight of Benin and Gulf of Guinea

## References

Assuncao R.M & Krainski E.T skater (n.d): *Spatial 'K'luster Analysis by Tree Edge Removal* https://www.rdocumentation.org/packages/spdep/versions/1.2-7/topics/skater

Calkins K. G (2005) *Applied Statistics - Lesson 5, Correlation Coefficients*

https://www.andrews.edu/\~calkins/math/edrm611/edrm05.htm#:\~:text=Correlation%20coefficients%20whose%20magnitude%20are,can%20be%20considered%20highly%20correlated.

Nowosad J. (2019), *Map coloring: the color scale styles available in the tmap package* https://geocompr.github.io/post/2019/tmap-color-scales/

ONG, J (2022), Geospatial Analytics for Social Good - U*nderstanding Nigeria Water functional and non-functional water point rate* https://jordan-isss624-geospatial.netlify.app/posts/geo/geospatial_exercise/#visualising-of-distribution-using-ggplot
