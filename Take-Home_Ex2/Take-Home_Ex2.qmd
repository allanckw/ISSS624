---
title: "Take Home Exercise 2 - Regionalization of Nigeria with Water points"
author: "Allan Chong"
editor: visual
execute: 
  warning: false
  message: false
---

## Overview

Water is a crucial resource for humanity. People must have access to clean water in order to be healthy. It promotes a healthy environment, peace and security, and a sustainable economy. However, more than 40% of the world's population lacks access to enough clean water. According to UN-Water, 1.8 billion people would live in places with a complete water shortage by 2025. One of the many areas that the water problem gravely threatens is food security. Agriculture uses over 70% of the freshwater that is present on Earth.

The severe water shortages and water quality issues are seen in underdeveloped countries. Up to 80% of infections in developing nations are attributed to inadequate water and sanitation infrastructure.

Despite technological advancement, providing rural people with clean water continues to be a key development concern in many countries around the world, especially in those on the continent of Africa.

The spatial patterns of non-functional water points will be shown in this study by using the proper global and local spatial association methodologies. We look at Nigeria's in this assignment.

## Getting Started

First, we load the required packages in R

-   **Spatial data handling**

    -   **sf**, **rgdal** and **spdep**

-   **Attribute data handling**

    -   **knitr, tidyverse**, **funModeling** especially **readr**, **ggplot2** and **dplyr**

-   **Choropleth mapping**

    -   **tmap**

-   **Multivariate data visualization and analysis**

    -   **coorplot**, **ggpubr**, and **heatmaply**

-   **Cluster analysis**

    -   **cluster**

    -   **ClustGeo**

```{r}
pacman::p_load(knitr, rgdal, spdep, tmap, sf, 
               ggpubr, cluster, funModeling,
               factoextra, NbClust, #factoextra factor analysis, access clustering results
               heatmaply, corrplot, psych, tidyverse)
```

### Spatial Data

The spatial dataset used in this assignment is the Nigeria Level-2 Administrative Boundary spatial dataset downloaded from Center for Humanitarian Data - [Nigeria - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-nga)

We will load the spatial features by using `st_read()` from the **sf** package

As the data we want is in WSG-84 format, we set *crs* to 4326.

We won't utilize `st_transform()` at this time because it can result in outputs with missing points after transformation, which would skew our study.

```{r}
nga = st_read(dsn = "data/geospatial",
               layer = "nga_admbnda_adm2_osgof_20190417",
               crs = 4326)

#nigeria_lga_sf = st_transform(nigeria_lga_sf, crs=4326) cause missing points

```

We could use `st_crs()`to verify the coordinate system from the object.

```{r}
st_crs(nga)
```

Before we start analyzing the data, lets us take a look at some characteristics of the spatial features to have a sense of what we are dealing with. We can use *`glimpse()`* to determine to accomplish that

```{r}
glimpse(nga)
```

We can use `freq()` of the **funModeling** package to display the distribution of Level 1 administration (Which are states in Nigeria) instead and only zooming in on the micro level when we perform the water point analysis.

```{r}
freq(data=nga, input = 'ADM1_EN')
```

774 Local Government Areas (LGA) make up Nigeria's 37 states, with Kano having the most LGAs overall.

For a meaningful analysis, there are just too many LGAs, both large and little.

Calling `ttm()` in the **tmap** package will switch the tmap's viewing mode to interactive viewing, which will help us better visualize the map. Without this change, the generated map will be too small for any type of analysis. Additionally, we'll base the map's plot on States (Level 1 Administration Area)

Given that there are 37 states, we must raise the maximum number of categories from the default value of 30 to 37. Using `tmap_options(max.categories = 37)`, the threshold can be set.

```{r}
ttm()
tmap_options(max.categories = 37)
```

Now, we are ready to build our map with the functions in the **tmap** package

```{r}

tm_shape(nga) + 
 
  tm_polygons("ADM1_EN") +
  tm_borders(alpha=0.5) + 
  tm_scale_bar() +
  tm_grid (alpha=0.2) +
  tm_layout(main.title="Map of Nigeria LGA", 
            main.title.position="center", 
            main.title.size=1.2, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) 
```

### Aspatial Data

#### Cleaning the Data

The aspatial dataset used in this assignment is the water point data exchange dataset found in [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/). Data is filtered on the web portal to only keep Nigeria and the file is saved as *NigeriaWaterPoints_Raw.csv*

As we are only interested in the functionality of the water point, it is important to capture fields that may may aid us in our analysis (Definition are found here: [Source](https://data.waterpointdata.org/dataset/Water-Point-Data-Exchange-Plus-WPdx-/eqje-vguj))

-   LGA: The area we are interested in

-   State: The state of the LGA of Nigeria

-   Functional: Whether it is functional or not

-   Management: who manages it?

-   Quality: what is the quality?

-   Water Source Category: where the water came from?

-   Water Tech Category: What technology is used?

-   is_urban: Is it in an urban area?

-   #distance_to_primary_road: Based on calculations with data from OpenStreetMap, the distance in km to the nearest road.

-   #distance_to_secondary_road: Based on calculations using OpenStreetMap data, the distance in km to the second-closest road.

-   #distance_to_tertiary_road: Using calculations with data from OpenStreetMap, the distance to the third-closest road is given in km.

-   Usage Capacity: Maximum recommended number of users per waterpoint

-   latitude

-   longitude

To load the raw data file, we use the `read_csv` function

```{r}
#| eval: false
wpdx_raw = read_csv("data/aspatial/NigeriaWaterPoints_Raw.csv") 
```

Most of the columns are irrelevant, so we will perform the following:

-   keep the columns we want to clean it up by specifying the columns with one to retain with `subset`

-   renaming the columns using `rename_with`

-   Replace all the NA with unknown for columns with NA value present

```{r}
#| eval: false
retain_cols = c('#clean_adm2', '#clean_adm1', '#status_clean', '#management_clean'
                , '#subjective_quality', '#water_source_category', 
                '#water_tech_category', 
                '#lat_deg', '#lon_deg','is_urban','#distance_to_primary_road',
                '#distance_to_secondary_road', '#distance_to_tertiary_road'
                ,'usage_capacity')

new_col_names = c('LGA', 'State', 'Functional', 'Management', 
                  'Quality',  'Water_Source_Category', 'Water_Tech_Category',
                  'latitude', 'longitude', 'Is_Urban_Area', 'dist_to_primary_road'
                  ,'dist_to_secondary_road', 'dist_to_tertiary_road'
                  ,'usage_capacity')

wpdx_clean = subset(wpdx_raw, select = (names(wpdx_raw) %in% retain_cols)) %>%  rename_with(~ new_col_names, all_of(retain_cols)) %>% 
replace_na(list(Functional = "Unknown", Management = "Unknown", Quality = "Unknown", Water_Source_Category = "Unknown", Water_Tech_Category = "Unknown"))



```

We save the clean file with `saveRDS()`, the file will be reduced to 1.6MB from the 144MB raw file that we downloaded.

```{r}
#| eval: false
saveRDS(wpdx_clean, "data/aspatial/wpdx_clean_ex2.rds")
```

We can then delete the raw file from the project and retrieve the saved RDS file using `readRDS()`

```{r}
wpdx_clean = readRDS("data/aspatial/wpdx_clean_ex2.rds")

```

#### Converting csv data into spatial features

We can use `st_as_sf`to create a dataframe from the longitude (*x*) and latitude (*y*) values. The EPSG 4326 code is used as the dataset is referencing WGS84 geographic coordinate system. We could use `st_crs()`to verify the coordinate system from the object.

```{r}
wpdx_clean_sf = st_as_sf(wpdx_clean, coords = c("longitude", "latitude"), crs=4326)
st_crs(wpdx_clean_sf)
```

We can then use *`glimpse()`* to verify each field's data type & available values.

There are 95, 008 water points in the LGAs. The results also shows that the longitude and latitude values have been converted to a geometry object consisting of the longitude and latitude values as points, with both columns now dropped.

```{r}
glimpse(wpdx_clean_sf)
```

#### Data points of interest

In this assignment, we will attempt to regionalize Nigeria based on the following variables:

-   Total number of functional water points

-   Total number of nonfunctional water points

-   Percentage of functional water points

-   Percentage of non-functional water points

-   Percentage of main water point technology (i.e. Hand Pump)

-   Percentage of usage capacity (i.e. \< 1000, \>=1000)

-   Percentage of rural water points

-   Percentage of potable vs non potable water points

-   Percentage of water points accessible within median of primary road network

-   Percentage of water points accessible within median of secondary road network

-   Percentage of water points accessible within median of tertiary road network

```{=html}
<!-- -->
```
-   Percentage of water points that are managed

#### Exploratory Data Analysis (EDA)

We can use `freq()` of the **funModeling** package to display the distribution of *our data points of interest using wpdx_clean_sf*. This is to help us aggregate the data as the dataset provide breakdowns of their respective catagories.

##### Categorical Variables

```{r}
freq(data=wpdx_clean_sf, input = 'Functional')
```

Checking out functionality, we know that functional water points are broken down into *Functional, Functional but needs repair,* and *Functional but not in use.* 48.29% are functional, 4.82% are functional but needs repair and 1.77% of them are functional but not in use.

```{r}
freq(data=wpdx_clean_sf, input = 'Water_Tech_Category')
```

Checking out water technology, we know that water points are broken down into *Hand pumps, Mechanized Pump, Tapstand, Rope and bucket.* 61.84% of water points operates on hand pumps, 26.99% on mechanized pumps, 10.58% are unknowns and a minority of them (less than 0.58%) are either on tapstand or Rope and Bucket.

```{r}
freq(data=wpdx_clean_sf, input = 'Quality')
```

Checking out the quality of water points, we know that 75.57% of them are of acceptable quality, with an additional 0.04% of them within potable national limits / standards. The rest are either unknown or of unacceptable quality.

```{r}
freq(data=wpdx_clean_sf, input = 'Management')
```

Checking out water point management, we know that water points are mostly managed except 37.8% which are unknowns

##### Continuous Variables

We will need to find out the summary of the respective distance in order to categorize them appropriately for analysis. We can achieve that by using summary statistics in R

```{r}
summary(wpdx_clean_sf$dist_to_primary_road)
```

```{r}
summary(wpdx_clean_sf$dist_to_secondary_road)
```

```{r}
summary(wpdx_clean_sf$dist_to_tertiary_road)
```

Based on the results above, we know that the median distance (in km) to primary, secondary and tertiary roads is 6647.50 km, 4446.0 km and 1442.4 km respectively. We can use within median distance to analyze if accessibility to water points is a factor to regionalization

#### Aggregate the Data

To aggregate the variable of interest, we will create new data frames to store them by using the `filter` function. Variables names used are self explanatory.

```{r}
func_list = c("Functional", "Functional but needs repair", "Functional but not in use")
wpt_functional_true = wpdx_clean_sf %>%
  filter(Functional %in% func_list)

wpt_functional_false = wpdx_clean_sf %>%
  filter(!Functional %in% c(func_list, "Unknown"))

wpt_functional_unknown = wpdx_clean_sf %>%
  filter(Functional %in% "Unknown")

wpt_rural = wpdx_clean_sf %>%
  filter(Is_Urban_Area == FALSE)

wpt_handpumps_true = wpdx_clean_sf %>%
  filter(Water_Tech_Category %in% "Hand Pump")

wpt_handpumps_false = wpdx_clean_sf %>%
  filter(!Water_Tech_Category %in% "Hand Pump")

wpt_potable_true = wpdx_clean_sf %>%
  filter(Quality %in% c("Acceptable quality", "Within National standards (potable)
", "Within National limits (potable)"))

wpt_potable_false = wpdx_clean_sf %>%
  filter(!Quality %in% c("Acceptable quality", "Within National standards (potable)
", "Within National limits (potable)", "Unknown"))

wpt_potable_unknown = wpdx_clean_sf %>%
  filter(!Quality %in% "Unknown")

wpt_usageOver1000 = wpdx_clean_sf %>%
  filter(usage_capacity >= 1000)

wpt_usageLessThan1000 = wpdx_clean_sf %>%
  filter(usage_capacity < 1000)

wpt_accessibility_PriRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_primary_road < 6647.50)
  
wpt_accessibility_PriRd_moreThanMedian = wpdx_clean_sf %>%
  filter(dist_to_primary_road >= 6647.50)

wpt_accessibility_secRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_secondary_road < 4446.0  )
  
wpt_accessibility_secRd_moreThanMedian = wpdx_clean_sf %>%
  filter(dist_to_secondary_road >= 4446.0  )
  
wpt_accessibility_TerRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_tertiary_road < 1442.4  )
  
wpt_accessibility_TerRd_moreThanMedian = wpdx_clean_sf %>%
  filter(dist_to_tertiary_road >= 1442.4  )

wpt_managed_true = wpdx_clean_sf %>%
  filter(!Management %in% "Unknown")

wpt_managed_unknown = wpdx_clean_sf %>%
  filter(Management %in% "Unknown")
```

## Combining Spatial & Aspatial Data

We can use `st_intersects()` to find common data points between geographical datasets. In our case we need to find the common points in the Nigeria's LGA spatial dataset and the water point aspatial dataset

The below code does 4 things

1.  It intersects the Nigeria LGA dataset (*nga* dataframe) with the water point dataset (*wpdx_clean_sf* dataframe) and produce a new column to denote the total number of water points in the area (*Total wpt*) by using `mutate()` and `lengths()`

2.  Similar to step 1, the result of step 1 is piped to add 3 columns to denote the number of functional, non functional and unknown water points in the area to produce *wpt functional*, *wpt non functional* and *wpt unknown* respectively

3.  We also add 2 new columns to find the percentage of functional and non functional water points by using `mutate()`

4.  Select appropriate columns required which are the LGA area and LGA code (Column 3 & 4), Administration Level 1 Area and Administration Level 1 Code (Column 8 & 9) which represent states, the columns that were added as explained in steps 2 & 3 and the geometry multipolygon objects (Column 18 to 23) using `select()`

```{r}
nga_wp = nga %>% 
  #combine nga with water point sf
  mutate(`total wpt` = lengths(
    st_intersects(nga, wpdx_clean_sf))) %>%
  #add columns to produce no. of functional, non functional and unknown points
  mutate(`wpt functional` = lengths(
    st_intersects(nga, wpt_functional))) %>%
  mutate(`wpt non functional` = lengths(
    st_intersects(nga, wpt_non_functional))) %>%
  mutate(`wpt unknown` = lengths(
    st_intersects(nga, wpt_unknown))) %>%
  mutate(`isRural` = lengths(
    st_intersects(nga, wpt_rural))) %>%
  
  #add columns to compute %
  mutate(pct_functional = `wpt functional`/`total wpt`) %>%
  mutate(`pct_non-functional` = `wpt non functional`/`total wpt`) #%>%
  #select(3:4, 8:9, 18:23)
```

#### Updating Spatial features that have identical name but are in different states

The following code determines whether any LGA names have been repeated. If the shapeName is not unique for rows, duplicated() returns True. Only rows that satisfy the duplicated rows = True criterion are returned by subset() (Loh, 2022).

```{r}
subset(nga_wp, duplicated(nga_wp$ADM2_EN))$ADM2_EN
```

From the result, there are 6 LGAs that have the same names, even though they are from different states. We will want to rename them or it would be confusing when we conduct further analysis.

```{r}
nga_wp %>% filter(grepl("Bassa",ADM2_EN)) 
```

Based on the values, we know the ADM2_PCODE of the respective Bassa are NG023004 (Kogi) and NG032002 (Plateau), so we will replace them using the code below.

```{r}
nga_wp$ADM2_EN[nga_wp$ADM2_PCODE=="NG023004"] = 'Bassa (Kogi)'
nga_wp$ADM2_EN[nga_wp$ADM2_PCODE=="NG032002"] = 'Bassa (Plateau)'
```

We repeat the same for the rest of the duplicates and we have the final results as follow

```{r}
z = nga_wp %>% filter(grepl("Ifelodun",ADM2_EN)) 
nga_wp$ADM2_EN[nga_wp$ADM2_PCODE=="NG024005"] = 'Ifelodun (Kwara)'
nga_wp$ADM2_EN[nga_wp$ADM2_PCODE=="NG030016"] = 'Ifelodun (Osun)'


z = nga_wp %>% filter(grepl("Irepodun",ADM2_EN)) 
nga_wp$ADM2_EN[nga_wp$ADM2_PCODE=="NG024009"] = 'Irepodun (Kwara)'
nga_wp$ADM2_EN[nga_wp$ADM2_PCODE=="NG030020"] = 'Irepodun (Osun)'

```

## Visualizing the spatial distribution of water points

We could use breaks of the summary statistics by using percentiles, this is to help us find out the distribution of water points in each quantile.

```{r}
summary(nga_wp$`wpt non functional`)
```

It is recommended not to use the default style with breaks as quantile since the range from the third quantile to the maximum is too wide and could result in a skewed representation. We compute the variance and standard deviation of non-functional water points first to better understand our dataset since we now need to decide which style is appropriate for the map.

```{r}
var(nga_wp$`wpt non functional`)
sd(nga_wp$`wpt non functional`) 
```

It appears that this dataset has a very large variance.  Since the variance is so high, we would like to lower it. Using the *kmeans* style is one method to do this. *n = 6* is choosen as after some experimentation, it appears that 6 is the optimal number of clusters.

Functions from the **tmap** packages is used to produce the map

First we use `tm_shape()` `+ tm_fill("ADM1_EN")` to form Layer 1 of the map to form the 37 states of the map. The *Pastel1* palette is used because it is difficult to read different shades of the same two to three colors; Pastel1 has more colors, making states more distinct.

Next we use `tm_shape()` `+ tm_fill("wpt non functional")` to form Layer 2 of the map which are the non functional water points. The palette used in this case is Purple Red such that areas with very little water points are shaded with a very light colour.

We may switch between layers on the interactive map to superimpose the nonfunctional water locations. With so many polygons, putting it side by side can be challenging to interpret.

```{r}
tm_shape(nga) + 
 
  tm_fill("ADM1_EN", palette = "Pastel1") +
  tm_borders(alpha=0.5) + 
  tm_grid (alpha=0.2) +

  tm_shape(nga_wp) + 
  tm_fill("wpt non functional", 
          palette ="PuRd", style="kmeans", n=6) +  
  tm_borders(alpha=0.5) + 
  tm_grid (alpha=0.2) +
  tm_layout(main.title="non functional WP - 2 Layer map", 
            main.title.position="center", 
            main.title.size=1.2, 
            #legend.height = 0.35, 
            #legend.width = 0.35, 
            frame = TRUE) 


```

Using **dplyr** package, we can summarize find out which States has the most number non functional water points and which are the states that has the most number of LGAs by using the functions `group_by`, `summarise` and `arrange`

```{r}
#Sum of non functional water points 
nga_wp %>% 
  group_by(ADM1_EN) %>% 
   summarise(NF_Frequency = sum(`wpt non functional`), 
             #F_Frequency = sum(`wpt functional`),
             Total_Freq = sum(`total wpt`),
             NF_Ratio = (NF_Frequency / Total_Freq) * 100
             ) %>% 
    arrange(desc(NF_Frequency))

#sum of LGAs by states 
nga_wp %>% 
  group_by(ADM1_EN) %>% 
  summarise(count = n())%>% 
    arrange(desc(count))
```

Reference

LOH, S.Y (2022), *Take-home Exercise 1: Geospatial Analytics for Social Good*

https://lohsiying.netlify.app/take_home_ex/ex1/take-home-ex1.html
