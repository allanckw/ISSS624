---
title: "Take Home Exercise 2 - Regionalization of Nigeria with Water points"
author: "Allan Chong"
editor: visual
execute: 
  warning: false
  message: false
---

## Overview

Water is a crucial resource for humanity. People must have access to clean water in order to be healthy. It promotes a healthy environment, peace and security, and a sustainable economy. However, more than 40% of the world's population lacks access to enough clean water. According to UN-Water, 1.8 billion people would live in places with a complete water shortage by 2025. One of the many areas that the water problem gravely threatens is food security. Agriculture uses over 70% of the freshwater that is present on Earth.

The severe water shortages and water quality issues are seen in underdeveloped countries. Up to 80% of infections in developing nations are attributed to inadequate water and sanitation infrastructure.

Despite technological advancement, providing rural people with clean water continues to be a key development concern in many countries around the world, especially in those on the continent of Africa.

We will attempt to regionalize Nigeria with the water points attributes in this exercise.

#### Data points of interest

In this assignment, we will attempt to regionalize Nigeria based on the following variables:

-   Total number of functional water points

-   Total number of nonfunctional water points

-   Percentage of functional water points

-   Percentage of non-functional water points

-   Percentage of main water point technology (i.e. Hand Pump)

-   Percentage of usage capacity (i.e. \< 1000, \>=1000)

-   Percentage of rural water points

-   Percentage of potable vs non potable water points

-   Percentage of water points accessible within median of primary road network

-   Percentage of water points accessible within median of secondary road network

-   Percentage of water points accessible within median of tertiary road network

-   Percentage of water points that are managed

## Getting Started

First, we load the required packages in R

-   **Spatial data handling**

    -   **sf** and **spdep**

-   **Attribute data handling**

    -   **tidyverse** especially **readr**, **ggplot2** and **dplyr** and **funModeling**

-   **Choropleth mapping**

    -   **tmap**

-   **Multivariate data visualization and analysis**

    -   **coorplot**, **ggpubr**, **GGally** and **heatmaply**

-   **Cluster analysis**

    -   **cluster**

    -   **ClustGeo**

```{r}
pacman::p_load(knitr, rgdal, spdep, tmap, sf, 
               ggpubr, GGally, cluster, funModeling,
               factoextra, NbClust, ClustGeo,
               heatmaply, corrplot, psych, tidyverse)
```

## Spatial Data

The spatial dataset used in this assignment is the Nigeria Level-2 Administrative Boundary spatial dataset downloaded from [Geoboundaries](https://www.geoboundaries.org/)

We will load the spatial features by using `st_read()` from the **sf** package

As the data we want is in WSG-84 format, we set *crs* to 4326.

We won't utilize `st_transform()` at this time because it can result in outputs with missing points after transformation, which would skew our study.

```{r}
#| eval: false
nga = st_read(dsn = "data/geospatial",
               layer = "geoBoundaries-NGA-ADM2",
               crs = 4326)
```

### Updating Spatial features that have identical name but are in different states

The following code determines whether any LGA names have been repeated. If the shapeName is not distinct for rows, duplicated() returns True. Only rows that satisfy the duplicated rows = True criterion are returned by `subset()` (Ong, 2022).

```{r}
#| eval: false
duplicate = nga$shapeName[nga$shapeName %in% nga$shapeName[duplicated(nga$shapeName)]]

duplicate
```

From the result, there are 12 LGAs that have the same names, even though they are from different states. We will want to rename them or it would be confusing when we conduct further analysis.

Firstly, we create a data frame with the duplicate

```{r}
#| eval: false
nga_dupes = nga %>%
  filter(shapeName %in% duplicate)
```

Calling `ttm()` in the **tmap** package will switch the tmap's viewing mode to interactive viewing, which will help us find the states of the respective duplicates in the map. We then plot the map with **tmap** functions

```{r}
#| eval: false
ttm()
tm_shape(nga_dupes) + 
  tm_polygons("shapeName") +
  tm_view(set.zoom.limits = c(5,10)) +
  tm_borders(alpha=0.5) 

```

From the result, we can observe the following:

| shapeID                    | shapeName           |
|----------------------------|---------------------|
| NGA-ADM2-72505758B95534398 | Bassa (Kogi)        |
| NGA-ADM2-72505758B52690633 | Bassa (Plateau)     |
| NGA-ADM2-72505758B26581542 | Ifelodun (Kwara)    |
| NGA-ADM2-72505758B18326272 | Ifelodun (Osun)     |
| NGA-ADM2-72505758B75034141 | Irepodun (Kwara)    |
| NGA-ADM2-72505758B79178637 | Irepodun (Osun)     |
| NGA-ADM2-72505758B6786568  | Nasarawa (Kano)     |
| NGA-ADM2-72505758B67188591 | Nasarawa (Nasarawa) |
| NGA-ADM2-72505758B7318634  | Obi (Benue)         |
| NGA-ADM2-72505758B3073896  | Obi (Nasarawa)      |
| NGA-ADM2-72505758B6675111  | Surulere (lagos)    |
| NGA-ADM2-72505758B31597260 | Surulere (Oyo)      |

Based on the results above, we replace the *shapeNames* with *shapeID* as the identifier and run the duplicate check again to verify that it is now empty

```{r}
#| eval: false
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B95534398'] = 'Bassa (Kogi)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B52690633'] = 'Bassa (Plateau)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B26581542'] = 'Ifelodun (Kwara)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B18326272'] = 'Ifelodun (Osun)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B75034141'] = 'Irepodun (Kwara)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B79178637'] = 'Irepodun (Osun)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B6786568'] = 'Nasarawa (Kano)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B67188591'] = 'Nasarawa (Nasarawa)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B7318634'] = 'Obi (Benue)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B3073896'] = 'Obi (Nasarawa)'

nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B6675111'] = 'Surulere (lagos)'
nga$shapeName[nga$shapeID=='NGA-ADM2-72505758B31597260'] = 'Surulere (Oyo)'

duplicate = nga$shapeName[nga$shapeName %in% nga$shapeName[duplicated(nga$shapeName)]]

duplicate
```

Once we are done, we simply remove the unnecessary columns and keep only *shapeName* and save the data frame with `saveRDS()`

```{r}
#| eval: false
nga = nga %>%
  select(shapeName)

saveRDS(nga, "data/geospatial/nga_ex2.rds")
```

We can then retrieve the cleaned RDS file using `readRDS(),` and set the tmap mode to interactive viewing

```{r}
nga = readRDS("data/geospatial/nga_ex2.rds")
ttm()
```

## Aspatial Data

### Cleaning the Data

The aspatial dataset used in this assignment is the water point data exchange dataset found in [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/). Data is filtered on the web portal to only keep Nigeria and the file is saved as *NigeriaWaterPoints_Raw.csv*

As we are only interested in the functionality of the water point, it is important to capture fields that may may aid us in our analysis (Definition are found here: [Source](https://data.waterpointdata.org/dataset/Water-Point-Data-Exchange-Plus-WPdx-/eqje-vguj))

-   LGA: The area we are interested in

-   State: The state of the LGA of Nigeria

-   Functional: Whether it is functional or not

-   Management: who manages it?

-   Quality: what is the quality?

-   Water Source Category: where the water came from?

-   Water Tech Category: What technology is used?

-   is_urban: Is it in an urban area?

-   #distance_to_primary_road: Based on calculations with data from OpenStreetMap, the distance in km to the nearest road.

-   #distance_to_secondary_road: Based on calculations using OpenStreetMap data, the distance in km to the second-closest road.

-   #distance_to_tertiary_road: Using calculations with data from OpenStreetMap, the distance to the third-closest road is given in km.

-   Usage Capacity: Maximum recommended number of users per waterpoint

-   New Georeferenced Column: : Well Known Text **(wkt)** representing spatial data in a textual format

To load the raw data file, we use the `read_csv` function

```{r}
#| eval: false
wpdx_raw = read_csv("data/aspatial/NigeriaWaterPoints_Raw.csv") 
```

Most of the columns are irrelevant, so we will perform the following:

-   keep the columns we want to clean it up by specifying the columns with one to retain with `subset`

-   renaming the columns using `rename_with`

-   Replace all the NA with unknown for columns with NA value present

```{r}
#| eval: false
retain_cols = c('#clean_adm2', '#clean_adm1', '#status_clean', '#management_clean'
                , '#subjective_quality', '#water_source_category', 
                '#water_tech_category', 
                'New Georeferenced Column', 'is_urban','#distance_to_primary_road',
                '#distance_to_secondary_road', '#distance_to_tertiary_road'
                ,'usage_capacity')

new_col_names = c('LGA', 'State', 'Functional', 'Management', 
                  'Quality',  'Water_Source_Category', 'Water_Tech_Category',
                  'WKT', 'Is_Urban_Area', 'dist_to_primary_road'
                  ,'dist_to_secondary_road', 'dist_to_tertiary_road'
                  ,'usage_capacity')

wpdx_clean = subset(wpdx_raw, select = (names(wpdx_raw) %in% retain_cols)) %>%  rename_with(~ new_col_names, all_of(retain_cols)) %>% 
replace_na(list(Functional = "Unknown", Management = "Unknown", Quality = "Unknown", Water_Source_Category = "Unknown", Water_Tech_Category = "Unknown"))



```

We save the processed data frame *wpdx_clean* into a file, the file will be reduced to 3.4 MB from the 144 MB raw file that we downloaded.

```{r}
#| eval: false
saveRDS(wpdx_clean, "data/aspatial/wpdx_clean_ex2.rds")
```

We can then delete the raw file from the project and retrieve the saved RDS file using `readRDS()`

```{r}
wpdx_clean = readRDS("data/aspatial/wpdx_clean_ex2.rds")
```

### Converting csv data into spatial features

We can use `st_as_sfc()` to come up with the new field *Geometry* by using the WKT field

```{r}
wpdx_clean$Geometry = st_as_sfc(wpdx_clean$`WKT`)
```

We will then use `st_sf()` to convert the tibble data frame into sf data frame. The EPSG 4326 code is used as the dataset is referencing WGS84 geographic coordinate system.

We could use `st_crs()`to verify the coordinate system from the object.

```{r}
wpdx_clean_sf = st_sf(wpdx_clean, crs=4326) 
st_crs(wpdx_clean_sf)
```

Lastly, the attribute data from the *nga* sf data frame will be transferred into the *wpdx_clean_sf* data frame using a geoprocessing function known as point-in-polygon overlay. `st_join()` from the sf package can help us with that

```{r}
nga_wp = st_join(wpdx_clean_sf, nga)
```

## Exploratory Data Analysis (EDA)

We can use `freq()` of the **funModeling** package to display the distribution of *our data points of interest using wpdx_clean_sf*. This is to help us aggregate the data as the dataset provide breakdowns of their respective categories.

### Categorical Variables

```{r}
freq(data=nga_wp, input = 'Functional')
```

Checking out functionality, we know that functional water points are broken down into *Functional, Functional but needs repair,* and *Functional but not in use.*

48.29% are functional, 4.82% are functional but needs repair and 1.77% of them are functional but not in use. To aggregate the data, Abandoned and Decommissioned water points will be grouped as non functional water points

```{r}
freq(data=nga_wp, input = 'Management')
```

Checking out water point's management, we know that more than half of the water points are managed except 37.8% which are unknowns

```{r}
freq(data=nga_wp, input = 'Quality')
```

Checking out the quality of water points, we know that 75.57% of them are of acceptable quality, with an additional 0.04% of them within potable national limits / standards. We will aggregate Acceptable Quality, Within National Standards (Potable) and Within National Limits (Potable) as Potable water in general for this analysis.

```{r}
freq(data=nga_wp, input = 'Water_Source_Category')
```

Checking out the source of water points, we know that majority of them (96.35%) comes from some well. With such a high number, this variable may not be useful for our analysis as most of the data points will contain this value.

```{r}
freq(data=nga_wp, input = 'Water_Tech_Category')
```

Checking out the technology the water point uses, we know that water points are broken down into *Hand pumps, Mechanized Pump, Tapstand, Rope and bucket.* 61.84% of water points operates on hand pumps, 26.99% on mechanized pumps, 10.58% are unknowns and a minority of them (0.58%) are either on tapstand or Rope and Bucket.

```{r}
freq(data=nga_wp, input = 'Is_Urban_Area')
```

From the records, only 20.59% of the water points are in urban areas, while the rest of them (79.41%) are in the rural areas.

```{r}
freq(data=nga_wp, input = 'usage_capacity')
```

Majority of the water points caters to 300 people or less (73.1%), while 26.99% of the water points caters to a capacity of at least 1000 people

### Continuous Variables

We will need to find out the summary of the respective distance in order to categorize them appropriately for analysis. We can achieve that by using `summary` statistics in R

```{r}
summary(nga_wp$dist_to_primary_road)
```

```{r}
summary(nga_wp$dist_to_secondary_road)
```

```{r}
summary(nga_wp$dist_to_tertiary_road)
```

Based on the results above, we know that the median distance (in km) to primary, secondary and tertiary roads is 6647.5 km, 4446.0 km and 1442.4 km respectively. We can use within median distance to analyze if accessibility to water points is a factor to regionalization

### Aggregate the Data

To aggregate the variable of interest, we will create new data frames to store them by using the `filter` function. Variables names used are self explanatory.

```{r}
#| eval: false
func_list = c("Functional", "Functional but needs repair", "Functional but not in use")
wpt_functional_true = wpdx_clean_sf %>%
  filter(Functional %in% func_list)

wpt_functional_false = wpdx_clean_sf %>%
  filter(!Functional %in% c(func_list, "Unknown"))

wpt_rural = wpdx_clean_sf %>%
  filter(Is_Urban_Area == FALSE)

wpt_handpumps_true = wpdx_clean_sf %>%
  filter(Water_Tech_Category %in% "Hand Pump")

wpt_handpumps_false = wpdx_clean_sf %>%
  filter(!Water_Tech_Category %in% "Hand Pump")

wpt_potable_true = wpdx_clean_sf %>%
  filter(Quality %in% c("Acceptable quality", "Within National standards (potable)
", "Within National limits (potable)"))

wpt_potable_false = wpdx_clean_sf %>%
  filter(!Quality %in% c("Acceptable quality", "Within National standards (potable)
", "Within National limits (potable)", "Unknown"))

wpt_potable_unknown = wpdx_clean_sf %>%
  filter(!Quality %in% "Unknown")

wpt_usageOver1000 = wpdx_clean_sf %>%
  filter(usage_capacity >= 1000)

wpt_usageUnder1000 = wpdx_clean_sf %>%
  filter(usage_capacity < 1000)

wpt_accessibility_PriRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_primary_road < 6647.50)

wpt_accessibility_secRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_secondary_road < 4446.0  )
  
wpt_accessibility_TerRd_lessThanMedian = wpdx_clean_sf %>%
  filter(dist_to_tertiary_road < 1442.4  )

wpt_managed_true = wpdx_clean_sf %>%
  filter(!Management %in% "Unknown")

wpt_managed_unknown = wpdx_clean_sf %>%
  filter(Management %in% "Unknown")
```

### Computing our data points of interest

We can use `st_intersects()` to find common data points between the geographical datasets. In our case, we need to find the common points in the Nigeria's LGA spatial dataset and the water point aspatial dataset

As an example, the below code intersects the Nigeria LGA dataset (*nga* dataframe) with the water point dataset (*wpdx_clean_sf* dataframe) and produce a new column to denote the total number of water points in the area (*Total wpt*) by using `mutate()` and `lengths()`

```{r}
#| eval: false
nga_wp = nga %>% 
  #combine nga with water point sf
  mutate(`total wpt` = lengths(
    st_intersects(nga, wpdx_clean_sf)))
```

Similarly, for the rest of the variables, we piped the output and add the new columns to denote the number of

-   water points are functional & non functional

-   Water points that are in rural areas

-   Water points that either uses Hand pumps or otherwise

-   Water points that have either potable or non potable water

-   Water points with usage capacity of over 1000 persons or under

-   Water points within Median distance of Primary, Secondary and Tertiary roads

-   Water points management that are managed

```{r}
#| eval: false
nga_wp = nga %>% 
  #combine nga with water point sf
  mutate(`total wpt` = lengths(
    st_intersects(nga, wpdx_clean_sf))) %>%
  #add columns to produce no. of functional, non functional and unknown points
  mutate(`wpt functional` = lengths(
    st_intersects(nga, wpt_functional_true))) %>%
  mutate(`wpt non functional` = lengths(
    st_intersects(nga, wpt_functional_false))) %>%
  # rural
  mutate(`isRural` = lengths(
    st_intersects(nga, wpt_rural))) %>%
  # hand pumps
  mutate(`Uses Handpumps` = lengths(
    st_intersects(nga, wpt_handpumps_true))) %>%
  # Potable
   mutate(`Potable` = lengths(
    st_intersects(nga, wpt_potable_true))) %>%
  mutate(`Non Potable` = lengths(
    st_intersects(nga, wpt_potable_false))) %>%
  # Usage Capacity
  mutate(`usage Over 1000` = lengths(
    st_intersects(nga, wpt_usageOver1000))) %>%
  mutate(`usage Under 1000` = lengths(
    st_intersects(nga, wpt_usageUnder1000))) %>%
  #Primary Road
  mutate(`Within Median Distance to Pri Road` = lengths(
    st_intersects(nga, wpt_accessibility_PriRd_lessThanMedian))) %>%
  
  #Secondary Road
  mutate(`Within Median Distance to Sec Road` = lengths(
    st_intersects(nga, wpt_accessibility_secRd_lessThanMedian))) %>%

  #Tertiary Road
  mutate(`Within Median Distance to Ter Road` = lengths(
    st_intersects(nga, wpt_accessibility_PriRd_lessThanMedian))) %>%

  #management
  mutate(`Managed` = lengths(
    st_intersects(nga, wpt_managed_true))) 
  
  
```

Once we are done with the raw data, we use the below code to compute the respective percentages

-   percentage of functional water points

-   percentage of non functional water points

-   percentage of water points with hand pumps as technology

-   percentage of water points with potable / non potable water

-   percentage of water points with capacity over/under 1000

-   percentage of water points that are managed

-   percentage of water points in rural areas

-   percentage of water points are within the median distance to primary road network

-   percentage of water points are within the median distance to secondary road network

-   percentage of water points are within the median distance to tertiary road network

```{r}
#| eval: false
nga_wp = nga_wp %>%
  #add columns to compute %
  mutate(`pct_functional` = `wpt functional`/`total wpt`) %>%
  mutate(`pct_non-functional` = `wpt non functional`/`total wpt`) %>%

  mutate(`pct_Handpump` = `Uses Handpumps`/`total wpt`) %>%

  mutate(`pct_Potable` = `Potable`/`total wpt`) %>%
  mutate(`pct_NonPotable` = `Non Potable`/`total wpt`) %>%
  
  mutate(`pct_Cap_Over_1000` = `usage Over 1000`/`total wpt`) %>%
  mutate(`pct_Cap_Under_1000` = `usage Under 1000`/`total wpt`) %>%
    
  mutate(`pct_managed` = `Managed`/`total wpt`) %>%
  mutate(`pct_rural` = `isRural`/`total wpt`) %>%
  
  mutate(`pct_w_meddist_to_PriRoad` = `Within Median Distance to Pri Road`/`total wpt`) %>%
  
  mutate(`pct_w_meddist_to_SecRoad` = `Within Median Distance to Sec Road`/`total wpt`) %>%
  
  mutate(`pct_w_meddist_to_TerRoad` = `Within Median Distance to Ter Road`/`total wpt`) 
```

Once we are done with adding the new columns, we can inspect the data by viewing the data frame. It can be observed that some rows contains *NaN* values as a result of division by zero. We will replace these *NaN* values to 0 with the `is.na()` function. We will also change the row names to the names of the LGAs with `row.names()` by using `row.names()`

```{r}
#| eval: false
nga_wp[is.na(nga_wp)] = 0
row.names(nga_wp) = nga_wp$shapeName
```

The following variables will be retained as the rest are intermediate data points that are no longer relevant by using `select()`. We can verify that the columns are correct by using `colnames()`

1.  wpt functional

2.  wpt non functional

3.  pct_functional

4.  pct_non-functional

5.  pct_Handpump

6.  pct_Potable

7.  pct_NonPotable

8.  pct_Cap_Over_1000

9.  pct_Cap_Under_1000

10. pct_managed

11. pct_rural

12. pct_w\_meddist_to_PriRoad

13. pct_w\_meddist_to_SecRoad

14. pct_w\_meddist_to_TerRoad

```{r}
#| eval: false
nga_wp_interested_data_pts = nga_wp  %>% 
      select(4:5, 16:27) 
colnames(nga_wp_interested_data_pts)
```

We save the processed data frame *nga_wp_interested_data_pts* into a file with `saveRDS()`, so that we do not need to process it again

```{r}
#| eval: false
saveRDS(nga_wp_interested_data_pts, "data/geospatial/nga_wp_interested_data_points.rds")
```

We can then retrieve the saved RDS file using `readRDS()` and check that the column names are correct before we proceed further with `colnames()`

```{r}
nga_wp_interested_data_pts = readRDS("data/geospatial/nga_wp_interested_data_points.rds")

colnames(nga_wp_interested_data_pts)
```

### EDA using statistical graphics

A Histogram is useful to identify the overall distribution of the data values (i.e. positively skew, negatively skew or normal distribution)

We use **ggplot2**'s histogram (`geom_histogram`) to plot the percentage functional and non functional water points with the mean and median as abline using `geom_vline()`

We plot them side by side using `ggarrange`

```{r}
functional_pct_histo = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$pct_functional)),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$pct_functional)),   
               color="brown", linetype="dashed", linewidth=1)

nonfunctional_pct_histo = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_non-functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Non Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_non-functional` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_non-functional`)),   
               color="brown", linetype="dashed", linewidth=1)


ggarrange(functional_pct_histo, nonfunctional_pct_histo, ncol = 2, nrow = 1)

```

From the result, we can observe that both functional and non functional water points distributions are positively skewed. It follows a normal distribution with its mean and median very close to each other.

We can also use box plot to detect outliers with `geom_boxplot`. We plot them side by side using `ggarrange`

```{r}
functional_boxplot = ggplot(data=nga_wp_interested_data_pts, 
       aes(x=`pct_functional`)) +
       labs(x = "% Functional") +
       geom_boxplot(color="black", fill="light green")

nonfunctional_boxplot = ggplot(data=nga_wp_interested_data_pts, 
       aes(x=`pct_non-functional`)) + 
       labs(x = "% Non Functional") +
       geom_boxplot(color="black", fill="light green") 
  

ggarrange(functional_boxplot, nonfunctional_boxplot, ncol = 2, nrow = 1)
```

We can see that there isn't any outliers for the functional water points, but for non functional water points, there are outliers where 100% of the water points are non functional.

In the figure below, multiple histograms are plotted to reveal the distribution of the selected variables in the *nga_wp_interested_data_pts* data frame.

First, We do this by creating all the histograms assigned to individual variables by using `ggplot()`.

```{r}

functional = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `wpt functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "No. of Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`wpt functional`)), 
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`wpt functional`)), color="brown", linetype="dashed", linewidth=1)

nonfunctional = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `wpt non functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "No. of Non Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`wpt non functional` )),color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`wpt non functional`)),color="brown", linetype="dashed", linewidth=1)

functional_pct = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_functional` )),color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_functional`)), color="brown", linetype="dashed", linewidth=1)

nonfunctional_pct = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_non-functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Non Functional", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_non-functional` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_non-functional`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_Handpump = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_Handpump`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Handpump", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Handpump` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Handpump`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_Potable = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_Potable`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Potable", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Potable` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Potable`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_NonPotable = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_NonPotable`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Non Potable", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_NonPotable` )),   color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_NonPotable`)),    color="brown", linetype="dashed", linewidth=1)


pct_Usage_Capacity_Over_1000 = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_Cap_Over_1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Usage capacity >= 1000", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Cap_Over_1000` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Cap_Over_1000`)),   
               color="brown", linetype="dashed", linewidth=1)


pct_Usage_Capacity_Under_1000 = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_Cap_Under_1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Usage capacity < 1000", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Cap_Under_1000` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Cap_Under_1000`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_managed = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_managed`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Managed", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_managed` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_managed`)),   
               color="brown", linetype="dashed", linewidth=1)


pct_rural = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_rural`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
  labs(x = "% Rural", y = "Frequency") +
  geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_rural` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_rural`)),   
               color="brown", linetype="dashed", linewidth=1)


pct_within_median_dist_to_pri_road = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_w_meddist_to_PriRoad`)) +
              geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
                 labs(x = "% Within Median distance to Primary Road", 
                      y = "Frequency") +
                geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_PriRoad` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_PriRoad`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_within_median_dist_to_sec_road = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_w_meddist_to_SecRoad`)) +
              geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
                 labs(x = "% Within Median distance to Secondary Road", 
                     y = "Frequency") +
                geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_SecRoad` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_SecRoad`)),   
               color="brown", linetype="dashed", linewidth=1)

pct_within_median_dist_to_ter_road = ggplot(data=nga_wp_interested_data_pts, 
             aes(x= `pct_w_meddist_to_TerRoad`)) +
              geom_histogram(bins=20, 
                 color="black", 
                 fill="light green") +
                labs(x = "% Within Median distance to Tertiary Road", 
                     y = "Frequency") +
                geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_TerRoad` )),   
               color="red", linetype="dashed", linewidth=1) +
  geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_TerRoad`)),   
               color="brown", linetype="dashed", linewidth=1)



```

We can build a trellis plot with the code below after creating our graphs with `ggarrange()` to create 14 histograms. and organised them into a 3 columns by 5 rows small multiplot.

```{r}
#| eval: false
ggarrange(functional, nonfunctional, 
          functional_pct, nonfunctional_pct,
          pct_Potable, pct_NonPotable, 
          pct_Usage_Capacity_Over_1000, pct_Usage_Capacity_Under_1000,
          pct_managed, pct_rural,
          pct_within_median_dist_to_pri_road, 
          pct_within_median_dist_to_sec_road, 
          pct_within_median_dist_to_ter_road, 
          pct_Handpump,
          ncol = 3, nrow = 5)
```

![Trellis Plot](trellisplot.png){fig-align="center" width="891"}

From the Trellis plot, we can observe that most of the variables does not follow a Normal Distribution, except for % functional and % non functional.

> *As number of functional and number of non functional water points are **NOT** in the same units as the other variables in percentage, we will need to standardize them later.*

### Visualizing the spatial distribution of water points

We will plot the map with the **tmap** package. In this exercise we will use the *jenks* style as it looks for clusters of related values and highlights the differences between categories. (Nowosad, 2019)

```{r}
nga_wp_interested_data_pts.map.pct_func = 
  tm_shape(nga_wp_interested_data_pts) + 
  tm_fill("pct_functional", 
          palette ="PuRd", style="jenks", n = 5) +  
  tm_borders(alpha=0.5) + 
  tm_grid (alpha=0.2) +
  tm_view(set.zoom.limits = c(5,10)) +
  tm_layout(main.title="% functional WP", 
            main.title.position="center", 
            main.title.size=0.8, 
            frame = TRUE) 
 
nga_wp_interested_data_pts.map.pct_nonfunc = 
  tm_shape(nga_wp_interested_data_pts) + 
  tm_fill("pct_non-functional", 
          palette ="PuRd", style="jenks", n = 5) +  
  tm_borders(alpha=0.5) + 
  tm_grid (alpha=0.2) +
  tm_view(set.zoom.limits = c(5,10)) +
  tm_layout(main.title="% non functional WP", 
            main.title.position="center", 
            main.title.size=0.8, 
            frame = TRUE) 

tmap_arrange(nga_wp_interested_data_pts.map.pct_func, 
             nga_wp_interested_data_pts.map.pct_nonfunc, 
             asp=1, ncol=2, sync = TRUE)
```

From the results, we can observe the following:

-   The north east area of Nigeria have little to no water point at all

-   Functional water points congregate in the northern side of the country

-   Non functional water points congregates around the south western coast of Nigera, facing gulf of Guinea & Bight of Benin.

## Correlation Analysis

### Finding Correlated Variables

It is important that we ensure the cluster variables are not highly correlated before we conduct cluster analysis.

We will first remove the geometry object from the data frame using `st_set_geometry(NULL)`

```{r}
nga_wp_corr_vars = nga_wp_interested_data_pts %>%
          st_set_geometry(NULL)
```

We will use `corrplot.mixed()` ([ref](https://cran.r-project.org/web/packages/corrplot/corrplot.pdf)) function of the [**corrplot**](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html) package. However we need to find the correlation matrix first with `cor()`

```{r}
#| eval: false
cluster_vars.cor = cor(nga_wp_corr_vars) 

corrplot.mixed(cluster_vars.cor, 
               lower = "ellipse", 
               upper = "number", 
               tl.pos = "lt", 
               diag="l", 
               tl.col="black")

```

![](corr_matrix.png){fig-align="center"}

According to Calkins (2005), variables that can be regarded as having a high degree of correlation are indicated by correlation coefficients with magnitudes between ± 0.7 and 1.0.

As a result, the following **5 observations** are highly correlated:

1.  *pct_functional* vs. pct_managed - we will drop *pct_managed*

2.  pct_handpump vs. *pct_Cap_Over1000* and *pct_Cap_Under1000* - we will drop *pct_Cap_Over1000* and *pct_handpump*

3.  *pct_potable* vs. *pct managed* - *pct_managed* already drop in 1

4.  *pct_Cap_Over_1000* vs. *pct_Cap_Under1000* - *pct_Cap_Over1000* already drop in 2

5.  *pct_w\_meddist_to_PriRoad* vs. *pct_w\_meddist_to_TerRoad* - we will drop *pct_w\_meddist_to_TerRoad*

In conclusion, we will drop *pct_handpump (Column 5), pct_managed (Column 10), pct_Cap_Over1000* *(Column 8), and pct_w\_meddist_to_TerRoad (Column 14).* Using `select()`, we drop the respective columns.

At the end of it, we verify that the column names that are retained are correct by using `colnames()`

```{r}
nga_wp_corr_vars = nga_wp_corr_vars %>%
                   select(-5, -10, -8, -14)

colnames(nga_wp_corr_vars)
```

### Data Standardization

As most of the data points are already in percentages except *wpt functional* and *wpt non functional*, we will need to perform standardization so that they will be comparable.

From the Trellis plot generated earlier, we know that not all of the variables follow some normal distribution, so we will use ***Min-Max*** standardization instead of the Z-score standardization in this exercise.

To achieve that we can use the [**heatmaply**](https://cran.r-project.org/web/packages/heatmaply/) package's `normalize()` function. The `summary()` function is used to show the summary statistics for the standardized clustering variables.

```{r}
nga_wp_corr_vars.std_minmax = normalize(nga_wp_corr_vars)
summary(nga_wp_corr_vars.std_minmax)
```

We can see that the values range of the Min-max standardized clustering variables are between 0 and 1 now.

#### Visualizing the standardize clustering variables

It is a good idea to visualize the distribution graphical of the standardized clustering variables in addition to evaluating the summary statistics of those variables. We will use the **ggplot2** library to help us with that by plotting the raw variable distribution vs the standardized distribution

```{r}
r_func = ggplot(data=nga_wp_interested_data_pts, aes(x=`wpt functional`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`wpt functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`wpt functional`)),   
               color="brown", linetype="dashed", linewidth=1)

s_func = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`wpt functional`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`wpt functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`wpt functional`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_nfunc = ggplot(data=nga_wp_interested_data_pts, aes(x=`wpt non functional`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "Non Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`wpt non functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`wpt non functional`)),   
               color="brown", linetype="dashed", linewidth=1)

s_nfunc = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`wpt non functional`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "Non Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`wpt non functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`wpt non functional`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

ggarrange(r_func, s_func, r_nfunc, s_nfunc,
          ncol = 2,
          nrow = 2)
```

```{r}
r_pctFunc = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_functional`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_functional`)),   
               color="brown", linetype="dashed", linewidth=1)

s_pctFunc = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_functional`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_functional`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_pctNfunc = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_non-functional`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Non Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_non-functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_non-functional`)),   
               color="brown", linetype="dashed", linewidth=1)

s_pctNfunc = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_non-functional`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Non Functional", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_non-functional`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`wpt non functional`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

ggarrange(r_pctFunc, s_pctFunc, r_pctNfunc,s_pctNfunc,
          ncol = 2,
          nrow = 2)
```

```{r}

r_potable = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_Potable`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Potable", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Potable`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Potable`)),   
               color="brown", linetype="dashed", linewidth=1)

s_potable = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_Potable`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Potable", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_Potable`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_Potable`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_nonpotable = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_NonPotable`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Non Potable", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_NonPotable`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_NonPotable`)),   
               color="brown", linetype="dashed", linewidth=1)

s_nonpotable = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_NonPotable`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Non Potable", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_NonPotable`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_NonPotable`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")



ggarrange(r_potable, s_potable, r_nonpotable, s_nonpotable,
          ncol = 2,
          nrow = 2)
```

```{r}
r_capUnder1000 = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_Cap_Under_1000`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Usage Capacity < 1000", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_Cap_Under_1000`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_Cap_Under_1000`)),   
               color="brown", linetype="dashed", linewidth=1)

s_capUnder1000 = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_Cap_Under_1000`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Usage Capacity < 1000", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_Cap_Under_1000`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_Cap_Under_1000`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_rural = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_rural`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Rural", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_rural`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_rural`)),   
               color="brown", linetype="dashed", linewidth=1)

s_rural = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_rural`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Rural", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_rural`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_rural`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

ggarrange(r_capUnder1000, s_capUnder1000, r_rural, s_rural ,
          ncol = 2,
          nrow = 2)
```

```{r}

r_w_dist_toPriRoad = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_w_meddist_to_PriRoad`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Within Med Dist to Pri Road", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_PriRoad`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_PriRoad`)),   
               color="brown", linetype="dashed", linewidth=1)

s_w_dist_toPriRoad = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_w_meddist_to_PriRoad`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Within Med Dist to Pri Road", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_w_meddist_to_PriRoad`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_w_meddist_to_PriRoad`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")

r_w_dist_toSecRoad = ggplot(data=nga_wp_interested_data_pts, aes(x=`pct_w_meddist_to_SecRoad`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Within Med Dist to Sec Road", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_interested_data_pts$`pct_w_meddist_to_SecRoad`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_interested_data_pts$`pct_w_meddist_to_SecRoad`)),   
               color="brown", linetype="dashed", linewidth=1)

s_w_dist_toSecRoad = ggplot(data=nga_wp_corr_vars.std_minmax, aes(x=`pct_w_meddist_to_SecRoad`)) + 
    geom_histogram(bins=20, color="black", fill="light green") +
    labs(x = "% Within Med Dist to Sec Road", y = "Frequency") +
    geom_vline(aes(xintercept = mean(nga_wp_corr_vars.std_minmax$`pct_w_meddist_to_SecRoad`)),   
               color="red", linetype="dashed", linewidth=1) +
    geom_vline(aes(xintercept=median(nga_wp_corr_vars.std_minmax$`pct_w_meddist_to_SecRoad`)),   
               color="brown", linetype="dashed", linewidth=1) + ggtitle("Min-Max Standardization")



ggarrange(r_w_dist_toPriRoad , s_w_dist_toPriRoad, r_w_dist_toSecRoad , s_w_dist_toSecRoad, 
          ncol = 2,
          nrow = 2)
```

After observing the histograms, we can conclude that the distribution did not change for all of the variables. preserving the nature of the data post standardization.

#### Determine the proximity matrix.

With R's `dist()` function, we shall compute the proximity matrix. The six distance proximity calculations that are supported by `dist()` are the *euclidean, maximum, manhattan, canberra, binary,* and *minkowski* methods.

As the variables are largely dissimilar, we use the ***minkowski*** method to create our proximity matrix

```{r}
proxmat = dist(nga_wp_corr_vars.std_minmax, method="minkowski")
```

### Computing hierarchical clustering

Hierarchical clustering is an unsupervised machine learning technique that divides objects into clusters based on how related they are. The result is a collection of clusters, each of which differs from the others while having things that are generally similar to one another.

A tree-like diagram known as a Dendrogram is used to record the sequences of mergers and splits in the result of the clustering process.

We can use `hclust()` method provided by the R Stat class to find our clusters with our proximity matrix we found earlier using the *ward.d* method. The Dendrogram is drawn using `plot()` of R graphics

```{r}
#| fig.height = 10, fig.width = 10
hclust_ward_d = hclust(proxmat, method="ward.D")
plot(hclust_ward_d, cex=0.5) 
```

#### Selecting the optimal clustering algorithm

Finding stronger clustering structures is a challenge when performing hierarchical clustering. Using the `agnes()` function of the **cluster** package will address the issue.

It performs similar operations to `hclus()`, but `agnes()` also provides the agglomerative coefficient, which gauges the degree of clustering structure present

> ***values closer to 1 suggest strong clustering structure***

We define the different methods and name of them in the variable *m* and define a function to find the agglomerative coefficient (*ac*). By calling `map_dbl(m, ac)` we can iterate through the list to find the respective ac of the different functions

```{r}
m = c("average", "single", "complete", "ward")
names(m) = c("average", "single", "complete", "ward")

ac = function(y) {
  agnes(nga_wp_corr_vars.std_minmax, method=y)$ac
}

map_dbl(m,ac)
```

According to the results shown above, *Ward* approach offers the greatest clustering structure out of the four examined methods as it is closest to 1. Consequently, only Ward's technique will be applied in the analysis that follows.

### Determining Optimal Clusters

We can use the gap statistic contrasts the overall intra-cluster variation for various values of *k* with the values that would be predicted under a null reference distribution for the dataset.

The value that maximizes the gap statistic will be used to estimate the best clusters (i.e., that yields the largest gap statistic). In other words, the clustering structure is very different from a randomly distributed, uniform distribution of points.

To compute the gap statistic, [`clusGap()`](https://www.rdocumentation.org/packages/cluster/versions/2.1.0/topics/clusGap) of [**cluster**](https://cran.r-project.org/web/packages/cluster/) package will be used. with the [`hcut`](https://rpkgs.datanovia.com/factoextra/reference/hcut.html) function from [**factoextra**](https://rpkgs.datanovia.com/factoextra/) package. `hcut` calculates the hierarchical clustering and cuts the tree.

We set k.max to 10 as there are 10 variable involved and we want to find the global maximum to determine the best value of *k.*

```{r}
set.seed(12345)
gap_stat = clusGap(nga_wp_corr_vars.std_minmax, 
                   FUN=hcut, nstart=25, K.max = 10, B = 50)
# Print the result
print(gap_stat, method = "globalmax")
```

Next, we can visualize the plot by using [`fviz_gap_stat()`](https://rpkgs.datanovia.com/factoextra/reference/fviz_nbclust.html) of [**factoextra**](https://rpkgs.datanovia.com/factoextra/) package.

```{r}
fviz_gap_stat(gap_stat)
```

We can infer from the figure above that **9** **clusters** is the optimum number for the Hierarchical Clustering Algorithm.

Using **R stats'** `rect.hclust()` function, the dendrogram can alternatively be plotted with a border around the chosen clusters. The rectangles' borders can be colored using the option border.

```{r}
#| fig.height = 10, fig.width = 10
plot(hclust_ward_d, cex=0.6)
rect.hclust(hclust_ward_d, k = 9, border = 2:9)
```

### Visually-driven hierarchical clustering analysis

By using [**heatmaply**](https://cran.r-project.org/web/packages/heatmaply/) package we are able to build both highly interactive cluster heat map or static cluster heatmap.

```{r}
nga_wp_corr_vars.std_minmax_mat = data.matrix(nga_wp_corr_vars.std_minmax)
```

Plotting interactive cluster heat map using `heatmaply()`, to make it consistent, we will use the *minkowski* distance method.

```{r}
heatmaply(normalize(nga_wp_corr_vars.std_minmax_mat), 
          Colv=NA,
          dist_method = "minkowski",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors=PuRd,
          k_row = 9,
          margins= c(NA, 200, 60, NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main = "Segmentation of Nigeria water points",
          xlab = "Water point indicators",
          ylab = "Nigeria LGA"
          
          )
```

From the heat map, it can be observed that the following variables *pct_functional, pct_Potable, pct_Cap_Under_1000* & *pct_rural* are likely to form clusters of high concentrations between the LGAs.

### Mapping the clusters formed in hierarchical clustering

Following the analysis of the above, we will use $k=9$. The code below will use R Base's `cutree()` function to create a 9-cluster model.

```{r}
groups = as.factor(cutree(hclust_ward_d, k=9))
```

The groups object needs to be added to the *nga* simple feature object in order to visualize the clusters.

The following code snippet forms the join in 3 steps:

1.  The object representing the groups list will be transformed into a matrix;

2.  *nga* is appended with the groups matrix using `cbind()` to create the simple feature object *nga_wp_cluster*;

3.  The as.matrix.groups column is renamed to CLUSTER using the **dplyr** package's `rename()` function.

```{r}
nga_wp_cluster = cbind(nga, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

Next we use the **tmap** functions to plot the choropleth map showing the clusters

```{r}
nga_wp_hclust_map = tm_shape(nga_wp_cluster) + 
  tm_layout(main.title="Distribution of H Clusters", 
            main.title.position="center", 
            main.title.size=0.9, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) + 
  tm_polygons("CLUSTER") +
  tm_view(set.zoom.limits = c(5,10)) +
  tm_borders(alpha = 0.5) 

nga_wp_hclust_map
```

Without any spatial constraints, the map produced nine erratic groupings, and the regions that made up the clusters are dispersed throughout the map. This is sub optimal as there may be real world considerations that necessitates the regionalization of areas into distinct regions, such as urban planning.

## Spatially Constrained Clustering

Now that we know utilizing overarching clustering without spatial considerations can form fragmented clusters that are not optimal, lets looks at adding spatial constraints

### SKATER approach

SKATER stands for Spatial 'K'luster Analysis by Tree Edge Removal (Assuncao & Krainski (n.d)). This function starts with a set of edges, an input dataset and a number of cuts to form clusters that are homogeneous

We will use the `skater()` method of the **spdep** package to derive a geographically limited cluster in this section.

First We must first transform *nga* into a spatial polygons data frame. This is because only SP objects (*SpatialPolygonDataFrame*) are supported by the SKATER function.

```{r}
nga_sp = as_Spatial(nga)
```

#### Computing Neighbour List

The neighbours list from the polygon list will then be computed using the `poly2nb()` function of the **spdep** package.

```{r}
nga_sp.nb = poly2nb(nga_sp)
summary(nga_sp.nb)
```

From the output, there are 774 LGAs in Nigeria, Using the Queen's method, 1 of them has 14 neighbours, 1 of them is an island (no neighbour), and 2 of them only has 1 neighbour

We must create the weights matrix after determining the spatial weights. A isolated island can be found in the neighbor list's results. Since this island won't have any neighbors at all, it is not recommended to utilize a contiguity weight matrix. In light of this, we'll employ a weight matrix based on distance instead.

#### Building the weights matrix

As there is an island involved, we will build an adaptive weight matrix as all features should have at least one neighbour if we were to use a fixed distance matrix.

Using the k nearest neighbor (knn) technique, we can adjust how many neighbors each LGA has. As discussed in class, we set k in this instance to 8. The R functions used in this case are `knn2nb()` and `knearneigh()`

For distance based matrix, we will need to perform `st_transform()` first, and recreate the nga_sp for the *SpatialPolygonDataFrame*

```{r}
nga_local = st_transform(nga, crs=26392)
st_crs(nga_local)

nga_sp = as_Spatial(nga_local)
```

Before we can start building the matrix, we first need to find the coordinates

-   The longitude is the first variable in each centroid, this enables us to obtain only the longitude.

-   The latitude is the second variable in each centroid, this enables us to obtain only the latitude

-   Using the double bracket notation \[\[\]\] and the index, we can access the latitude & longitude values.

-   After getting the longitude and latitudes values, we can form the coordinates object named `coord` using `cbind`.

```{r}
longitude = map_dbl(nga_local$geometry, ~st_centroid(.x)[[1]]) #longitude index 1
latitude = map_dbl(nga_local$geometry, ~st_centroid(.x)[[2]]) #latitude index 2
coord = cbind(longitude, latitude)
```

We then run the algorithm to create the adaptive distance matrix using `knn2nb()` and `knearneigh()`

We set longlat to False as the projection have already been changed to EPSG 26392, Nigeria Mid Belt

```{r}
knn8 = knn2nb(knearneigh(coord, k=8, longlat = FALSE))
```

#### Computing minimum spanning tree

**Calculating edge costs**

The cost of each edge is determined using `nbcosts()` from the **spdep** package. Its nodes are separated by this distance. This function uses a data frame with observations vectors in each node to calculate the distance.

```{r}
lcosts = nbcosts(knn8, nga_wp_corr_vars.std_minmax_mat)
```

Next, in a manner similar to how we calculated the inverse of distance weights, we will include these costs into a weights object. In other words, we specify the recently computed *lcosts* as the weights in order to transform the neighbour list into a list weights object. To accomplish this, we can use using the `nb2listw()` function of **spdep** package. We will use the 'B' Style as it will be more robust

```{r}
nga_wp_corr_vars.std_minmax_mat.w = nb2listw(knn8, lcosts, style="B")
summary(nga_wp_corr_vars.std_minmax_mat.w)
```

**Finding the minimum spanning tree**

A minimum spanning trees is a graph where all the vertices are connected by weighted edges with no cycle with the minimum cost.

The minimum spanning tree is computed by using [`mstree()`](https://r-spatial.github.io/spdep/reference/mstree.html) of **spdep** package as shown in the code below. We can check its class and dimensions by using `class()` and `dim()`

```{r}
nga_wp_mst = mstree(nga_wp_corr_vars.std_minmax_mat.w)
class(nga_wp_mst)
dim(nga_wp_mst)
```

The MST plot method includes a mechanism to display the nodes' observation numbers in addition to the edge. We once again plot these along with the LGA lines. We can see how the initial neighbor list is condensed to a single edge that passes through every node

```{r}
#| fig.height = 10, fig.width = 10
plot(nga_sp, border=gray(0.6))
plot.mst(nga_wp_mst, coordinates(nga_sp), col="blue", 
         cex.lab=0.7, cex.circles=0.05, add=TRUE)
```

#### Computing spatially constrained clusters using SKATER method

We can compute the spatially constrained cluster using [`skater()`](https://r-spatial.github.io/spdep/reference/skater.html) of the **spdep** package.

Required inputs for the `skater()` function. 

-   Data matrix (to update the costs while units are being grouped),

-   the number of cuts (no. of variables - 1)

-   the first two columns of the MST matrix

```{r}
clust9 = skater(edge=nga_wp_mst[,1:2], #1st 2 col of MST
                data = nga_wp_corr_vars, #data matrix
                method = "minkowski",
                ncuts = 8 #number of cuts
                )
```

Finally, we can plot the pruned tree that shows the 9 clusters on top of the LGA area.

```{r}
#| fig.height = 20, fig.width = 20
plot(nga_sp, border=gray(.5))
plot(clust9,
     coordinates(nga_sp),
     cex.lab=0.5,
     groups.colors=c("red","green","blue", "brown", 
                     "orange", "darkgreen", "darksalmon", "gold2", "orchid"),
     cex.circles=0.005, 
     add=TRUE
     )
```

#### Visualizing the clusters in choropleth map

The code below is used to plot the newly derived clusters by using the SKATER method

```{r}
groups_mat = as.matrix(clust9$groups)
nga_wp_spatialcluster = cbind(nga_wp_cluster, as.factor(groups_mat)) %>% 
  rename(`SP_CLUSTER` = `as.factor.groups_mat.`)

nga_wp_spatialcluster_map = tm_shape(nga_wp_spatialcluster) + 
  tm_layout(main.title="Distribution of clusters with SKATER", 
            main.title.position="center", 
            main.title.size=0.9, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) + 
  tm_fill("SP_CLUSTER") +
  tm_view(set.zoom.limits = c(5,10)) +
  tm_borders(alpha = 0.5) 

nga_wp_spatialcluster_map
```

We can observe that once we added spatial constraints into the formula, there are 9 clusters that are mostly contiguous. This can help us make better decisions on what to do with each cluster and make planning easier when we need to consolidate resources.

The remarkable clusters are:

-   in the north eastern and eastern borders of Nigeria, where there are little to no water points,

-   the south western coast facing gulf of guinea and Bight of Benin where non functional water points congregate

-   North of Nigeria where functional points congregate

-   A really large cluster (Cluster 4) that covers almost the whole of Nigeria

### Spatially Constrained Clustering - ClustGeo Method

Another method of introducing spatial constraints to use the **ClustGeo** package. We can make use of the `hclustgeo()` function in the **ClustGeo** package to perform Ward-style hierarchical clustering.

First we will need to create the *`nga_clustgeo_HClust`* by using `hclustgeo()` with the proximity matrix we created in the previous section and plot its corresponding Dendrogram

```{r}
#| fig.height = 10, fig.width = 10
nga_clustgeo_HClust = hclustgeo(proxmat)
plot(nga_clustgeo_HClust, cex=0.5)
rect.hclust(nga_clustgeo_HClust, k=9, border = 2:9)
```

#### Mapping the clusters formed

Similarly, by applying the techniques we discovered in the section [*Mapping the clusters formed in hierarchical clustering*](https://mitb-isss624-ackw-gis-analytics.netlify.app/take-home_ex2/take-home_ex2#mapping-the-clusters-formed-in-hierarchical-clustering)*,* we may plot the clusters on a categorical area shaded map.

```{r}
groups = as.factor(cutree(nga_clustgeo_HClust, k=9))

nga_clustgeo_HClust_cluster = cbind(nga, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)

nga_clustgeo_HClust_cluster_map = tm_shape(nga_clustgeo_HClust_cluster) + 
   tm_layout(main.title="Distribution of clusters with HClustGeo", 
            main.title.position="center", 
            main.title.size=0.9, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) + 
  tm_polygons("CLUSTER") +
  tm_view(set.zoom.limits = c(5,10)) +
  tm_borders(alpha = 0.5) 

nga_clustgeo_HClust_cluster_map
```

Without spatial constraints, the map generated 9 clusters that are rather messy and the regions composing the clusters are dispersed throughout the map, which is sub-optimal. This is similar to the results we applied in the section [*Mapping the clusters formed in hierarchical clustering*](https://mitb-isss624-ackw-gis-analytics.netlify.app/take-home_ex2/take-home_ex2#mapping-the-clusters-formed-in-hierarchical-clustering).

#### Spatially Constrained Hierarchical Clustering

Prior to starting the spatially constrained hierarchical clustering process, a spatial distance matrix will need to be derived by using [`st_distance()`](https://r-spatial.github.io/sf/reference/geos_measures.html) of the **sf** package.

```{r}
dist = st_distance(nga, nga)
```

`as.dist()` is used to convert the data frame into a matrix.

```{r}
distmat = as.dist(dist)
```

Our goal is to as much as possible **retain the attribute homogeneity** but also **introduce spatial homogeneity**. In order to balance this, we can compute ***∝*** using the `choicealpha()` function.

```{r}
cr = choicealpha(proxmat, distmat, range.alpha = seq(0,1, 0.1), K=9, graph=T)
```

As the data is skewed as we have explored in our EDA, we will use the QNorm graph based on normalized values.

We can observe that when ***∝*** is raised from 0.2 to 0.4, the homogeneity of d1, which is our spatial relationship (contiguity matrix), gain significantly from about 50% to 80%. And for d0 (which is our attribute homogeneity), the loss is slightly more than 20%. Since ***∝ = 0.4*** is the most optimal, we will use it to form our cluster.

```{r}
clustG = hclustgeo(proxmat, distmat, alpha = 0.4)
```

We then use `cutree()` to derive the cluster object, and join it back to the *nga* polygon feature data frame by using `cbind()`

```{r}
groups = as.factor(cutree(clustG, k=9))
nga_clustgeo_HClust_cluster_CA  = cbind(nga, as.matrix(groups)) %>%
  rename(`SP_CLUSTER` = `as.matrix.groups.`)
```

We can now plot the map of the newly delineated spatially constraints clusters using functions of **tmap**

```{r}
nga_clustgeo_HClust_cluster_CA_map = 
  tm_shape(nga_clustgeo_HClust_cluster_CA) + 
     tm_layout(main.title="Distribution of clusters with HClustGeo using choice alpha", 
            main.title.position="center", 
            main.title.size=0.9, 
            legend.height = 0.35, 
            legend.width = 0.35, 
            frame = TRUE) + 
  tm_polygons("SP_CLUSTER") +
  tm_view(set.zoom.limits = c(5,10)) +
  tm_borders(alpha = 0.5) 

nga_clustgeo_HClust_cluster_CA_map
```

Similarly to the skater method of the **spdep** package, we can observe that once we added alpha into the formula, there are now 9 clusters that are mostly contiguous. This can help us make better decisions on what to do with each cluster and make planning easier when we need to consolidate resources.

## Comparing the Resultant map plots

We attempt to conclude by plotting the 4 maps together

```{r}
tmap_arrange(nga_wp_hclust_map, nga_wp_spatialcluster_map, 
             nga_clustgeo_HClust_cluster_map, nga_clustgeo_HClust_cluster_CA_map, 
             ncol = 2, nrow = 2, asp = 1,
             sync = TRUE)

```

Based on the results, it is clear that hierarchical clustering without spatial constraints produces messy, non-contiguous clusters, which is less than ideal if there are resource constraints. When planning is done without taking into account spatial considerations, this clustering may prove challenging.

The SKATER method produced a map that assumed the majority of the LGAs were homogeneous in cluster 4, resulting in a disproportionately big cluster. This might not be the optimal approach for this data set due to the size of the cluster. We will investigate the reasons in the next section

The ClustGeo approach produced a much more optimal result as it was able to clearly separate out distinct areas as compared to the skater method.

## Visual Interpretation of Clusters

Studies in the past have demonstrated how parallel coordinate plots can be used to reveal clustering variables effectively. We can use the [`ggparcoord()`](https://ggobi.github.io/ggally/reference/ggparcoord.html) function of the [**GGally**](https://ggobi.github.io/ggally/) package to achieve this.

Since we are interested in only the maps with spatial constraints, We will first need to combine our cluster data frame with our standardize correlated variables with `cbind()`.

```{r}

nga_wp_spatialcluster_wvar = cbind(nga_wp_spatialcluster, nga_wp_corr_vars.std_minmax) 

nga_clustgeo_HClust_cluster_CA_wvar = cbind(nga_clustgeo_HClust_cluster_CA, nga_wp_corr_vars.std_minmax) 
```

We then use `ggparcoord()`to plot the box plots across the 9 clusters

```{r}
#| fig.height = 20, fig.width = 50
ggparcoord(data = nga_wp_spatialcluster_wvar,
           columns=c(4:13),
           groupColumn = "SP_CLUSTER",
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE,
           title = "Multi Parallel BoxPlots of WP Variables by HClust - SKATER") +
  
           facet_grid(~ SP_CLUSTER) + 
           theme(axis.text.x = element_text(angle = 30, size = 6 ))
```

The parallel box plot shows the highest median for percentage of non functional water points is Cluster 5, followed by cluster 1, 4, 9, 8, 3, 7, 2, 6. The clustering algorithm correctly identified Cluster 6 to the North East of Nigeria, where there are very few water points.

In the previous section, we noted that the SKATER map produced a really large cluster: cluster 4. Let's investigate what are the contributing factors. We first filter the rows in cluster 4, and plot the multivariate box plot using `ggparcoord()`

```{r}
nga_wp_spatialcluster_wvar_c4 = nga_wp_spatialcluster_wvar %>%
filter(SP_CLUSTER == 4)

ggparcoord(data = nga_wp_spatialcluster_wvar_c4,
           columns=c(4:13),
           groupColumn = "SP_CLUSTER",
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE,
           title = "Cluster 4 of WP Variables by HClust - SKATER") +
  
           facet_grid(~ SP_CLUSTER) + 
           theme(axis.text.x = element_text(angle = 30, size = 6 ))
```

From the result, we see that the largest contributing factor to this trend is whether the area is rural or otherwise, followed by having potable water and a capacity of less than 1000.

We could infer that the clustering algorithm has grouped these similar rural areas that had potable water and capacity of less than 1000 together. Cluster 4 which spans 388 LGAs is unlikely to be homogeneous if we want to look at how non-functional water points are distributed. We shall look at the ClustGeo package's output in order to get additional insights.

Similarly, We use `ggparcoord()`to plot the box plots across the 9 clusters

```{r}
#| fig.height = 20, fig.width = 50
ggparcoord(data = nga_clustgeo_HClust_cluster_CA_wvar,
           columns=c(3:12),
           groupColumn = "SP_CLUSTER",
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE,
           title = "Multi Parallel BoxPlots of WP Variables by HClust - CLUSTGEO") +
           facet_grid(~ SP_CLUSTER) + 
           theme(axis.text.x = element_text(angle = 30, size = 6 ))
```

We also find the mean, median and standard deviation of the 9 cluster by using the `summarise()` function and format it using `kable()` of **knitt** package

```{r}
nga_clustgeo_HClust_cluster_CA_wvar %>%
  st_set_geometry(NULL)  %>% #remove spatial features
  group_by(SP_CLUSTER) %>%
  summarise(
            mean_wpt_functional = mean(wpt.functional),
            median_wpt_functional = median(wpt.functional),
            sd_wpt_functional = sd(wpt.functional),
            
            mean_wpt_nonfunctional = mean(wpt.non.functional),
            median_wpt_nonfunctional = median(wpt.non.functional),
            sd_wpt_nonfunctional = sd(wpt.non.functional),
    
            mean_pct_functional = mean(pct_functional),
            median_pct_functional = median(pct_functional),
            sd_pct_functional = sd(pct_functional),
            
            mean_pct_nonfunctional = mean(pct_non.functional),
            median_pct_nonfunctional = median(pct_non.functional),
            sd_pct_nonfunctional = sd(pct_non.functional),
            
            mean_pct_potable = mean(pct_Potable),
            median_pct_potable = median(pct_Potable),
            sd_pct_potable = sd(pct_Potable),
            
            mean_pct_nonpotable = mean(pct_NonPotable),
            median_pct_nonpotable = median(pct_NonPotable),
            sd_pct_nonpotable = sd(pct_NonPotable),
            
            mean_pct_usageUnder1000 = mean(pct_Cap_Under_1000),
            median_pct_usageUnder1000 = median(pct_Cap_Under_1000),
            sd_pct_usageUnder1000 = sd(pct_Cap_Under_1000),
            
            mean_pct_rural = mean(pct_rural),
            median_pct_rural = median(pct_rural),
            sd_pct_rural = sd(pct_rural),
            
            
            mean_pct_within_median_dist_to_PriRoad = mean(pct_w_meddist_to_PriRoad),
            median_pct_within_median_dist_to_PriRoad = median(pct_w_meddist_to_PriRoad),
            sd_pct_within_median_dist_to_PriRoad = sd(pct_w_meddist_to_PriRoad),

            mean_pct_within_median_dist_to_SecRoad = mean(pct_w_meddist_to_SecRoad),
            median_pct_within_median_dist_to_SecRoad = median(pct_w_meddist_to_SecRoad),
            sd_pct_within_median_dist_to_SecRoad = sd(pct_w_meddist_to_SecRoad)

            
            )  %>%
            kable()
```

The parallel box plot shows the highest median for percentage of non functional water points is Cluster 4, followed by cluster 6, 3, 5, 1, 8, 7, 9, 2. Interestingly, the area identified in cluster 2 has no water points at all.

The result also correctly identified the following, consistent with our observations in [*Visualizing the spatial distribution of water points*](Visualizing%20the%20spatial%20distribution%20of%20water%20points)

-   that Non functional water points congregates around the south western coast of Nigeria, facing gulf of Guinea & Bight of Benin which are cluster 4 and 5 respectively

-   The north east area of Nigeria have little to no water point at all, which are clusters 2 and 8

-   Functional water points congregate in the northern side of the country which is identified by cluster 7

### Interpretation of Results produced by ClustGeo

#### Cluster 4

Since we know cluster 4 has the highest percentage of non functional water points, lets first filter the rows in cluster 4, and plot the multivariate box plot using `ggparcoord()`

```{r}
nga_clustgeo_HClust_cluster_CA_wvar_4 = nga_clustgeo_HClust_cluster_CA_wvar %>%
filter(SP_CLUSTER == 4)

ggparcoord(data = nga_clustgeo_HClust_cluster_CA_wvar_4,
           columns=c(3:12),
           groupColumn = "SP_CLUSTER",
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE,
           title = "Cluster 4 of WP Variables by HClust - ClustGeo") +
  
           facet_grid(~ SP_CLUSTER) + 
           theme(axis.text.x = element_text(angle = 30, size = 6 ))
```

According to the results of cluster 4, which is primarily made up of rural areas, at least half of the LGAs

-   Have at least 34.85% of the water points that are functional.

-   With 51.53% of them within the median distance of a secondary road

-   With 24.5% having water points of low usage capacities

-   Contains at least 62.39% of the water points with potable water. However, the median of percentage functional water point is only at 34.85%. This cluster has a 27.54% difference between the percentage of water points with potable water and those with functional water points.

#### Cluster 5

To make our analysis complete, lets also look at cluster 5, adjacent to cluster 4 facing the Bight of Benin if we can spot similar trends.

Similarly, we will filter the rows in cluster 5, and plot the multivariate box plot using `ggparcoord()`

```{r}
nga_clustgeo_HClust_cluster_CA_wvar_5 = nga_clustgeo_HClust_cluster_CA_wvar %>%
filter(SP_CLUSTER == 5)

ggparcoord(data = nga_clustgeo_HClust_cluster_CA_wvar_5,
           columns=c(3:12),
           groupColumn = "SP_CLUSTER",
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE,
           title = "Cluster 5 of WP Variables by HClust - ClustGeo") +
  
           facet_grid(~ SP_CLUSTER) + 
           theme(axis.text.x = element_text(angle = 30, size = 6 ))
```

According to the results of cluster 5, it is primarily made up of rural areas like cluster 4. At least half of the LGAs

-   Have at least 40.71% of the water points that are functional.

-   Is more much accessible with 72.49% of them within the median distance of a secondary road

-   With 68.0% having water points of low usage capacities

-   Contains at least 69.21% of the water points with potable water. However, the median of percentage functional water point stands at 40.71%.

    This cluster has a 28.50% difference between the percentage of water points with potable water and and those with functional water points, when compared to cluster 4 of 27.54%.

#### Cluster 7

We also observed that the north of Nigeria has a significant number of functional water points, which is indicated in this map by cluster 7. Let's attempt to identify the patterns that made it possible.

Similarly, we will filter the rows in cluster 7, and plot the multivariate box plot using `ggparcoord()`

```{r}
nga_clustgeo_HClust_cluster_CA_wvar_7 = nga_clustgeo_HClust_cluster_CA_wvar %>%
filter(SP_CLUSTER == 7)

ggparcoord(data = nga_clustgeo_HClust_cluster_CA_wvar_7,
           columns=c(3:12),
           groupColumn = "SP_CLUSTER",
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE,
           title = "Cluster 7 of WP Variables by HClust - ClustGeo") +
  
           facet_grid(~ SP_CLUSTER) + 
           theme(axis.text.x = element_text(angle = 30, size = 6 ))
```

According to the results of cluster 7, like 4 & 5, is primarily made up of rural areas, we could hence infer that urbanization does not really contribute to whether a water point is functional or not

Similarly, at least half of the LGAs

-   Have at least 78.06% functional water points in its area.

-   90.46% of the water points in this cluster are small, as compared to cluster 4 (24.5%) and cluster 5 (68.0%), we might investigate if a higher number of smaller water points are the way to go instead of big ones. We might also want to probe if large water points are harder to maintain.

-   with 42.13% of them within the median distance of a secondary road

-   Contains at least 94.44% of the water points with potable water. The median of percentage functional water point stands at 78.06%.

    This cluster has a 16.38% difference between the percentage of water points with potable water and and those with functional water points, at least 10% lower as compared to 28.50% in cluster 5 and 27.54% in cluster 4

## Conclusion

To further investigate how the variables of interest interact with each other, we could form hypotheses and use regression techniques to prove them.

Since we know from the correlation matrix (and logically) that functional water points are likely to be managed and contain potable water. We may be able to alleviate the water shortage in Nigeria if we can identify the factors that can enable the Nigerian government to make water points with potable water functional, focusing on cluster 4 and 5 as priority.

Some other questions we can ask are

-   Are smaller water points better than bigger ones for functional water points?

-   Does distance from a road network to an area affects the functionality of water points?

-   Which variables will affect water points containing potable water to become non functional?

-   Which variables can influence non functional water points that contains potable water to become operational to serve the population?

## References

Assuncao R.M & Krainski E.T skater (n.d): *Spatial 'K'luster Analysis by Tree Edge Removal* https://www.rdocumentation.org/packages/spdep/versions/1.2-7/topics/skater

Calkins K. G (2005) *Applied Statistics - Lesson 5, Correlation Coefficients*

https://www.andrews.edu/\~calkins/math/edrm611/edrm05.htm#:\~:text=Correlation%20coefficients%20whose%20magnitude%20are,can%20be%20considered%20highly%20correlated.

ONG, J (2022), Geospatial Analytics for Social Good - U*nderstanding Nigeria Water functional and non-functional water point rate* https://jordan-isss624-geospatial.netlify.app/posts/geo/geospatial_exercise/#visualising-of-distribution-using-ggplot
